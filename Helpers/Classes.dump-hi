
==================== FINAL INTERFACE ====================
2016-09-10 22:22:53.933169 UTC

interface pegbo_FGCQSHOeNg054bfGSPqnnE:Helpers.Classes 7103
  interface hash: 5158c7388fd733c7cb333b22b702d57f
  ABI hash: 87751b6839f9867c3ab3b30fdf2d5e57
  export-list hash: 7040b2e0136d57cbe63a2fa554298642
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: bb82c46219965b3fd3e031274bc1af37
  sig of: Nothing
  used TH splices: False
  where
exports:
  Helpers.Classes.DistA{Helpers.Classes.distA Helpers.Classes.distMinMaxA Helpers.Classes.midElemA Helpers.Classes.multA}
  Helpers.Classes.DistB{Helpers.Classes.distB Helpers.Classes.distMinMaxB Helpers.Classes.midElemB Helpers.Classes.multB}
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
61202e03723d6b8de3b1d25f6c4e2521
  $dmdistMinMaxA ::
    Helpers.Classes.DistA a n =>
    forall (t :: * -> *). Data.Foldable.Foldable t => t a -> a -> n
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(1*U,A,C(U),C(C1(U)),A,A)><L,U(A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),1*C1(C1(U)),A,A)><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ a
                   @ n
                   $dDistA :: Helpers.Classes.DistA a n
                   @ (t :: * -> *)
                   eta :: Data.Foldable.Foldable t
                   eta1 :: t a ->
                 let {
                   $dOrd :: GHC.Classes.Ord a
                   = Helpers.Classes.$p1DistA @ a @ n $dDistA
                 } in
                 let {
                   distMax :: a -> n
                   = GHC.Base.$
                       @ a
                       @ (a -> n)
                       (Helpers.Classes.distA @ a @ n $dDistA)
                       (Data.Foldable.maximum @ t eta @ a $dOrd eta1)
                 } in
                 let {
                   distMin :: a -> n
                   = GHC.Base.$
                       @ a
                       @ (a -> n)
                       (Helpers.Classes.distA @ a @ n $dDistA)
                       (Data.Foldable.minimum @ t eta @ a $dOrd eta1)
                 } in
                 \ x :: a ->
                 Helpers.Classes.multA @ a @ n $dDistA (distMin x) (distMax x)) -}
caf6e931750af108ed498763d708d261
  $dmdistMinMaxB ::
    Helpers.Classes.DistB a n =>
    forall (t :: * -> *).
    Data.Foldable.Foldable t =>
    t (a n) -> a n -> n
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(1*U,A,C(U),C(C1(U)),A,A)><L,U(A,A,A,A,A,A,A,A,A,A,A,A,1*C1(C1(U)),1*C1(C1(U)),A,A)><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ (a :: * -> *)
                   @ n
                   $dDistB :: Helpers.Classes.DistB a n
                   @ (t :: * -> *)
                   eta :: Data.Foldable.Foldable t
                   eta1 :: t (a n) ->
                 let {
                   $dOrd :: GHC.Classes.Ord (a n)
                   = Helpers.Classes.$p1DistB @ a @ n $dDistB
                 } in
                 let {
                   distMax :: a n -> n
                   = GHC.Base.$
                       @ (a n)
                       @ (a n -> n)
                       (Helpers.Classes.distB @ a @ n $dDistB)
                       (Data.Foldable.maximum @ t eta @ (a n) $dOrd eta1)
                 } in
                 let {
                   distMin :: a n -> n
                   = GHC.Base.$
                       @ (a n)
                       @ (a n -> n)
                       (Helpers.Classes.distB @ a @ n $dDistB)
                       (Data.Foldable.minimum @ t eta @ (a n) $dOrd eta1)
                 } in
                 \ x :: a n ->
                 Helpers.Classes.multB @ a @ n $dDistB (distMin x) (distMax x)) -}
999120b99863106b08e5939221385704
  $dmmidElemA ::
    Helpers.Classes.DistA a n =>
    forall (t :: * -> *). Data.Foldable.Foldable t => t a -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,1*U,A,A,1*C1(C1(U)),A)><S(LLLLLLC(C(S))LLLLLLLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ a
                   @ n
                   $dDistA :: Helpers.Classes.DistA a n
                   @ (t :: * -> *)
                   eta :: Data.Foldable.Foldable t
                   eta1 :: t a ->
                 let {
                   $dOrd :: GHC.Classes.Ord n
                   = Helpers.Classes.$p2DistA @ a @ n $dDistA
                 } in
                 let {
                   $dEq :: GHC.Classes.Eq n = GHC.Classes.$p1Ord @ n $dOrd
                 } in
                 let {
                   dist' :: a -> n
                   = Helpers.Classes.distMinMaxA @ a @ n $dDistA @ t eta eta1
                 } in
                 Data.Foldable.foldr1
                   @ t
                   eta
                   @ a
                   (\ a1 :: a b :: a ->
                    let {
                      da :: n = dist' a1
                    } in
                    case GHC.Classes.==
                           @ n
                           $dEq
                           (GHC.Classes.max @ n $dOrd da (dist' b))
                           da of wild {
                      GHC.Types.False -> b GHC.Types.True -> a1 })
                   eta1) -}
fab8e707788ee80738fcc9da26ba989f
  $dmmidElemB ::
    Helpers.Classes.DistB a n =>
    forall (t :: * -> *). Data.Foldable.Foldable t => t (a n) -> a n
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,1*U,A,A,1*C1(C1(U)),A)><S(LLLLLLC(C(S))LLLLLLLLL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)><L,U>,
     Unfolding: InlineRule (0, True, False)
                (\ @ (a :: * -> *)
                   @ n
                   $dDistB :: Helpers.Classes.DistB a n
                   @ (t :: * -> *)
                   eta :: Data.Foldable.Foldable t
                   eta1 :: t (a n) ->
                 let {
                   $dOrd :: GHC.Classes.Ord n
                   = Helpers.Classes.$p2DistB @ a @ n $dDistB
                 } in
                 let {
                   $dEq :: GHC.Classes.Eq n = GHC.Classes.$p1Ord @ n $dOrd
                 } in
                 let {
                   dist' :: a n -> n
                   = Helpers.Classes.distMinMaxB @ a @ n $dDistB @ t eta eta1
                 } in
                 Data.Foldable.foldr1
                   @ t
                   eta
                   @ (a n)
                   (\ a1 :: a n b :: a n ->
                    let {
                      da :: n = dist' a1
                    } in
                    case GHC.Classes.==
                           @ n
                           $dEq
                           (GHC.Classes.max @ n $dOrd da (dist' b))
                           da of wild {
                      GHC.Types.False -> b GHC.Types.True -> a1 })
                   eta1) -}
09d3001a27892e1b92156f98263c7ab4
  class (GHC.Classes.Ord a, GHC.Classes.Ord n) =>
        DistA a n | a -> n, n -> a where
    distA :: a -> a -> n
    multA :: n -> n -> n
    distMinMaxA {- Has default method -} ::
      Data.Foldable.Foldable t => t a -> a -> n
    midElemA {- Has default method -} ::
      Data.Foldable.Foldable t => t a -> a
e9f1d1b038497022c36f42e61e4c908d
  class (GHC.Classes.Ord (a n), GHC.Classes.Ord n) =>
        DistB (a :: * -> *) n | a n -> n, n -> a n where
    distB :: a n -> a n -> n
    multB :: n -> n -> n
    distMinMaxB {- Has default method -} ::
      Data.Foldable.Foldable t => t (a n) -> a n -> n
    midElemB {- Has default method -} ::
      Data.Foldable.Foldable t => t (a n) -> a n
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

