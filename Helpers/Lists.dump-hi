
==================== FINAL INTERFACE ====================
2016-09-12 05:47:12.642717 UTC

interface pegbo_FGCQSHOeNg054bfGSPqnnE:Helpers.Lists 7103
  interface hash: 662472cec8c7cb140260ab8e87f10c14
  ABI hash: ef2fe3f1018c91989066bb63b1bab840
  export-list hash: a436165992904039544f32b58c9d6666
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: b5d1b62220cb540c043dcbd7548cc5a3
  sig of: Nothing
  used TH splices: False
  where
exports:
  Helpers.Lists.combinations
  Helpers.Lists.compL
  Helpers.Lists.compMapL
  Helpers.Lists.compMapR
  Helpers.Lists.compR
  Helpers.Lists.concatZip
  Helpers.Lists.foldlBind
  Helpers.Lists.generalNPerms
  Helpers.Lists.generalPerms
  Helpers.Lists.groupWithNs
  Helpers.Lists.iterateN
  Helpers.Lists.lengthIntegral
  Helpers.Lists.longer
  Helpers.Lists.longest
  Helpers.Lists.middle
  Helpers.Lists.middleElem
  Helpers.Lists.moveXTo
  Helpers.Lists.nPerms
  Helpers.Lists.nth
  Helpers.Lists.perms
  Helpers.Lists.shorter
  Helpers.Lists.shortest
  Helpers.Lists.subList
  Helpers.Lists.subSelect
  Helpers.Lists.takeThrough
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:Control.Monad 480c5067477275068c9b98be08410df9
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
84da64e4065d24a2c48543636841f766
  $sreplicateM1 :: [[a3]] -> [[a3]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
dadcfe7fd0f455e5bd589bd3875c38da
  $sreplicateM2 :: [[a3]]
  {- Unfolding: (\ @ a3 ->
                 Helpers.Lists.$sreplicateM1 @ a3 (GHC.Types.[] @ [a3])) -}
fc5870263c2ddfef0f8cd81f47fe5bca
  $w$snPerms :: GHC.Prim.Int# -> [GHC.Types.Int] -> [[GHC.Types.Int]]
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# w :: [GHC.Types.Int] ->
                 GHC.List.filter
                   @ [GHC.Types.Int]
                   (\ x :: [GHC.Types.Int] ->
                    case GHC.List.$wlenAcc
                           @ GHC.Types.Int
                           (Data.OldList.nubBy @ GHC.Types.Int GHC.Classes.eqInt x)
                           0 of ww2 { DEFAULT ->
                    GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# ww2 ww) })
                   (Helpers.Lists.$w$sreplicateM @ GHC.Types.Int ww w)) -}
d307a712ae0201e590558fec74910ca6
  $w$sreplicateM :: GHC.Prim.Int# -> [a3] -> [[a3]]
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0],
     Unfolding: (\ @ a3 ww :: GHC.Prim.Int# w :: [a3] ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0 ww) of wild {
                   GHC.Types.False -> Helpers.Lists.$sreplicateM2 @ a3
                   GHC.Types.True
                   -> let {
                        lvl2 :: [[a3]] = GHC.Types.: @ [a3] w (GHC.Types.[] @ [a3])
                      } in
                      letrec {
                        $wxs :: GHC.Prim.Int# -> [[a3]]
                          {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                        = \ ww1 :: GHC.Prim.Int# ->
                          case ww1 of ds1 {
                            DEFAULT -> GHC.Types.: @ [a3] w ($wxs (GHC.Prim.-# ds1 1))
                            1 -> lvl2 }
                      } in
                      Helpers.Lists.$sreplicateM1 @ a3 ($wxs ww) }) -}
0f9d583dae1ff26fbb21510d9d082681
  $wcombinations :: GHC.Prim.Int# -> [a] -> [[a]]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Inline: [0] -}
5f89008f4582a12aa71e7c46a018eb07
  $wgeneralNPerms :: GHC.Prim.Int# -> [a] -> [[a]]
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0],
     Unfolding: (\ @ a ww :: GHC.Prim.Int# w :: [a] ->
                 GHC.Base.map
                   @ [GHC.Types.Int]
                   @ [a]
                   (GHC.Base.map
                      @ GHC.Types.Int
                      @ a
                      (\ n' :: GHC.Types.Int -> GHC.List.!! @ a w n'))
                   (Helpers.Lists.$w$snPerms
                      ww
                      (case GHC.List.$wlenAcc @ a w 0 of ww2 { DEFAULT ->
                       GHC.Enum.eftInt 0 (GHC.Prim.-# ww2 1) }))) -}
fa0d1b8b01e2df3aebbb1684733b150f
  $wmoveXTo :: GHC.Classes.Eq a => a -> [a] -> [a] -> (# [a], [a] #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U><S,U><L,U>, Inline: [0],
     Unfolding: (\ @ a
                   w :: GHC.Classes.Eq a
                   w1 :: a
                   ww :: [a]
                   ww1 :: [a] ->
                 letrec {
                   go1 :: [a] -> Data.Monoid.First a
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [a] ->
                     case ds of wild {
                       []
                       -> (GHC.Base.Nothing @ a)
                            `cast`
                          (Sym (Data.Monoid.NTCo:First[0]) <a>_N)
                       : y ys
                       -> case GHC.Classes.== @ a w y w1 of wild1 {
                            GHC.Types.False -> go1 ys
                            GHC.Types.True
                            -> (GHC.Base.Just @ a y)
                                 `cast`
                               (Sym (Data.Monoid.NTCo:First[0]) <a>_N) } }
                 } in
                 case (go1 ww) `cast` (Data.Monoid.NTCo:First[0] <a>_N) of wild {
                   GHC.Base.Nothing -> (# ww, ww1 #)
                   GHC.Base.Just ds
                   -> (# Data.OldList.delete @ a w w1 ww,
                         GHC.Types.: @ a w1 ww1 #) }) -}
48f7f6fa8966f34690ea47d2d4d9db98
  $wnPerms :: GHC.Classes.Eq a => GHC.Prim.Int# -> [a] -> [[a]]
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>, Inline: [0],
     Unfolding: (\ @ a
                   w :: GHC.Classes.Eq a
                   ww :: GHC.Prim.Int#
                   w1 :: [a] ->
                 GHC.List.filter
                   @ [a]
                   (\ x :: [a] ->
                    case GHC.List.$wlenAcc
                           @ a
                           (Data.OldList.nubBy @ a (GHC.Classes.== @ a w) x)
                           0 of ww2 { DEFAULT ->
                    GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# ww2 ww) })
                   (Helpers.Lists.$w$sreplicateM @ a ww w1)) -}
e4995c51cb6f3c5f018c1c6f05d39e50
  $wtakeThrough :: (a -> GHC.Types.Bool) -> [a] -> (# [a], [a] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ a w :: a -> GHC.Types.Bool w1 :: [a] ->
                 letrec {
                   $wtWhile :: [a] -> [a] -> (# [a], [a] #)
                     {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
                   = \ ww :: [a] ww1 :: [a] ->
                     case ww1 of wild {
                       [] -> (# ww, GHC.Types.[] @ a #)
                       : b bs
                       -> case w b of wild1 {
                            GHC.Types.False
                            -> (# GHC.Base.++ @ a ww (GHC.Types.: @ a b (GHC.Types.[] @ a)),
                                  bs #)
                            GHC.Types.True
                            -> $wtWhile
                                 (GHC.Base.++ @ a ww (GHC.Types.: @ a b (GHC.Types.[] @ a)))
                                 bs } }
                 } in
                 $wtWhile (GHC.Types.[] @ a) w1) -}
fa737a656679d74728db7911c37cd1c3
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
ab9ae76ecc6610dd4c267fdfa2dd996c
  combinations :: GHC.Types.Int -> [a] -> [[a]]
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(1*U)><L,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a w :: GHC.Types.Int w1 :: [a] ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Helpers.Lists.$wcombinations @ a ww1 w1 }) -}
7632b2c4f47140c41a515942516dc56a
  compL :: (a -> a -> a) -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                (\ @ a -> Helpers.Lists.compMapL @ a @ a) -}
2637d9342c808a0bed122153a1404920
  compMapL :: (a -> a -> b) -> [a] -> [b]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ a @ b f :: a -> a -> b as :: [a] ->
                 letrec {
                   $wcompLTup :: [a] -> [b] -> (# [GHC.Prim.Any], [b] #)
                     {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                   = \ ww :: [a] ww1 :: [b] ->
                     case ww of wild {
                       [] -> (# GHC.Types.[] @ GHC.Prim.Any, ww1 #)
                       : ds ds1
                       -> case ds1 of wild1 {
                            [] -> (# GHC.Types.[] @ GHC.Prim.Any, ww1 #)
                            : ipv ipv1 -> $wcompLTup wild1 (GHC.Types.: @ b (f ds ipv) ww1) } }
                 } in
                 case $wcompLTup as (GHC.Types.[] @ b) of ww { (#,#) ww1 ww2 ->
                 GHC.List.reverse1 @ b ww2 (GHC.Types.[] @ b) }) -}
4186337a8491adab37fa33c6148c3fb7
  compMapR :: (a -> a -> b) -> [a] -> [b]
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: (\ @ a @ b f :: a -> a -> b as :: [a] ->
                 letrec {
                   $wcompRTup :: [a] -> [b] -> (# [GHC.Prim.Any], [b] #)
                     {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                   = \ ww :: [a] ww1 :: [b] ->
                     case ww of wild {
                       [] -> (# GHC.Types.[] @ GHC.Prim.Any, ww1 #)
                       : ds ds1
                       -> case ds1 of wild1 {
                            [] -> (# GHC.Types.[] @ GHC.Prim.Any, ww1 #)
                            : ipv ipv1
                            -> let {
                                 xs' :: [a] = GHC.List.init1 @ a ds wild1
                               } in
                               $wcompRTup
                                 xs'
                                 (GHC.Types.:
                                    @ b
                                    (f (Helpers.Lists.compMapR1 @ a wild (GHC.List.lastError @ a))
                                       (GHC.List.last @ a xs'))
                                    ww1) } }
                 } in
                 case $wcompRTup as (GHC.Types.[] @ b) of ww { (#,#) ww1 ww2 ->
                 ww2 }) -}
86c6b0367833a251878cd4b0394966c6
  compMapR1 :: [a] -> a -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
50f079ed51ba070a03d2e14ac61ff79e
  compR :: (a -> a -> a) -> [a] -> [a]
  {- Arity: 2, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                (\ @ a -> Helpers.Lists.compMapR @ a @ a) -}
11f2ca13806450785254efa436a15848
  concatZip :: [a] -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ @ a a1 :: [a] eta :: [a] ->
                 Helpers.Lists.concatZip1 @ a a1 eta) -}
6bb7d1f3394aeb212bf045ed7ae6a1a2
  concatZip1 :: [a] -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
9fc0ec2d4e1349dde0f84ac143b8dd92
  foldlBind :: GHC.Base.Monad m => a -> [a -> m a] -> m a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,1*C(C1(U)),A,1*C1(U),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ (m :: * -> *) $dMonad :: GHC.Base.Monad m x :: a ->
                 GHC.List.foldl
                   @ (a -> m a)
                   @ (m a)
                   (GHC.Base.>>= @ m $dMonad @ a @ a)
                   (GHC.Base.return @ m $dMonad @ a x)) -}
7e39c4ae06bc659c52b58b70fdee03c0
  generalNPerms :: GHC.Types.Int -> [a] -> [[a]]
  {- Arity: 2, Strictness: <S,U(U)><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a w :: GHC.Types.Int w1 :: [a] ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Helpers.Lists.$wgeneralNPerms @ a ww1 w1 }) -}
52645e2910e53087f89988dfe82ee383
  generalPerms :: [a] -> [[a]]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a x :: [a] ->
                 case GHC.List.$wlenAcc @ a x 0 of ww2 { DEFAULT ->
                 Helpers.Lists.generalNPerms @ a (GHC.Types.I# ww2) x }) -}
07e1a89fa20acdbb11a073520a2eae60
  groupWithNs :: [a] -> [GHC.Types.Int] -> [[a]]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
2f40b544d545e621c2fa7542db45b3e4
  iterateN :: (a -> a) -> a -> GHC.Types.Int -> a
  {- Arity: 3, Strictness: <L,C(U)><L,U><S(S),1*U(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a f :: a -> a x :: a n :: GHC.Types.Int ->
                 case n of ww { GHC.Types.I# ww1 ->
                 GHC.List.$w!!
                   @ a
                   (GHC.Base.build
                      @ a
                      (\ @ b c :: a -> b -> b[OneShot] _n :: b[OneShot] ->
                       GHC.List.iterateFB @ a @ b c f x))
                   ww1 }) -}
191a79eeaf95f07d22ff5545fa0aebc7
  lengthIntegral :: GHC.Real.Integral b => [a] -> b
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ @ a @ b $dIntegral :: GHC.Real.Integral b ->
                 let {
                   $dReal :: GHC.Real.Real b = GHC.Real.$p1Integral @ b $dIntegral
                 } in
                 let {
                   $dNum :: GHC.Num.Num b = GHC.Real.$p1Real @ b $dReal
                 } in
                 let {
                   lvl2 :: b -> b
                   = GHC.Num.+
                       @ b
                       $dNum
                       (GHC.Num.fromInteger @ b $dNum Helpers.Lists.lengthIntegral2)
                 } in
                 let {
                   z1 :: b
                   = GHC.Num.fromInteger @ b $dNum Helpers.Lists.lengthIntegral1
                 } in
                 letrec {
                   go1 :: [a] -> b {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [a] ->
                     case ds of wild { [] -> z1 : y ys -> lvl2 (go1 ys) }
                 } in
                 \ eta :: [a] -> go1 eta) -}
22481555197b33cff533c79268991fc7
  lengthIntegral1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 0) -}
b8f8147a8d61145564645a5b12405217
  lengthIntegral2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 1) -}
ee01360e43e644bc943155bedf7daeff
  longer :: [a] -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: (\ @ a a1 :: [a] b :: [a] ->
                 case GHC.List.$wlenAcc @ a a1 0 of ww2 { DEFAULT ->
                 case GHC.List.$wlenAcc @ a b 0 of ww1 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww2 ww1) of wild {
                   GHC.Types.False -> b GHC.Types.True -> a1 } } }) -}
1815c1f646a20a26bf5ac03c37c08e20
  longest :: [[a]] -> [a]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a eta :: [[a]] ->
                 Helpers.Lists.longest1 @ a eta) -}
5398e6bc8696949aab97fad56ea1057e
  longest1 :: [[a]] -> [a]
  {- Arity: 1, Strictness: <S,1*U> -}
909d05d5ca7984a0f50cc894980fe433
  middle :: [a] -> [a]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ @ a xs :: [a] ->
                 case GHC.List.$wlenAcc @ a xs 0 of ww2 {
                   DEFAULT
                   -> case xs of wild {
                        [] -> case GHC.List.scanl2 ret_ty [a] of {}
                        : ds1 xs1
                        -> case xs1 of wild1 {
                             [] -> GHC.List.init2 @ a : x xs2 -> GHC.List.init1 @ a x xs2 } }
                   1 -> GHC.Types.[] @ a
                   2 -> GHC.Types.[] @ a }) -}
23a48c7f5d429d47124b3605905acd32
  middleElem :: [a] -> GHC.Base.Maybe a
  {- Arity: 1, Strictness: <S,1*U> -}
ae231af30a7753d3d63ba295f25d4010
  moveXTo :: GHC.Classes.Eq a => a -> ([a], [a]) -> ([a], [a])
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><L,U><S(SL),1*U(U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a w :: GHC.Classes.Eq a w1 :: a w2 :: ([a], [a]) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 case Helpers.Lists.$wmoveXTo
                        @ a
                        w
                        w1
                        ww1
                        ww2 of ww3 { (#,#) ww4 ww5 ->
                 (ww4, ww5) } }) -}
f62c5016788277588f2b6ee3f18ba891
  nPerms :: GHC.Classes.Eq a => GHC.Types.Int -> [a] -> [[a]]
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A)><S,U(U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a w :: GHC.Classes.Eq a w1 :: GHC.Types.Int w2 :: [a] ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Helpers.Lists.$wnPerms @ a w ww1 w2 }) -}
1e19527e4f0ca44804602428b8db9984
  nth :: [a] -> GHC.Types.Int -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(1*U)> -}
f6a5a1afb2d15f020e8e0829544dcd28
  perms :: GHC.Classes.Eq a => [a] -> [[a]]
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A)><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a $dEq :: GHC.Classes.Eq a x :: [a] ->
                 case GHC.List.$wlenAcc @ a x 0 of ww2 { DEFAULT ->
                 Helpers.Lists.nPerms @ a $dEq (GHC.Types.I# ww2) x }) -}
26b5e3d60014e8a133232013c4bb3f30
  shorter :: [a] -> [a] -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: (\ @ a a1 :: [a] b :: [a] ->
                 case GHC.List.$wlenAcc @ a a1 0 of ww2 { DEFAULT ->
                 case GHC.List.$wlenAcc @ a b 0 of ww1 { DEFAULT ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww2 ww1) of wild {
                   GHC.Types.False -> b GHC.Types.True -> a1 } } }) -}
5b410b72c1a1d5ee96f24cc097bbc43c
  shortest :: [[a]] -> [a]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a eta :: [[a]] ->
                 Helpers.Lists.shortest1 @ a eta) -}
907566b83baa57c913aa234a982ad721
  shortest1 :: [[a]] -> [a]
  {- Arity: 1, Strictness: <S,1*U> -}
8289b87a6b0975ebb2a8fd2841f161fe
  subList :: GHC.Types.Int -> [a] -> GHC.Base.Maybe ([a], [a])
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U>,
     Unfolding: (\ @ a ds :: GHC.Types.Int ds1 :: [a] ->
                 case ds1 of wild {
                   [] -> GHC.Base.Nothing @ ([a], [a])
                   : ipv ipv1
                   -> case GHC.List.$wlenAcc @ a wild 0 of ww2 { DEFAULT ->
                      case ds of wild1 { GHC.Types.I# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww2 y) of wild2 {
                        GHC.Types.False
                        -> GHC.Base.Just @ ([a], [a]) (GHC.Types.[] @ a, wild)
                        GHC.Types.True
                        -> GHC.Base.Just
                             @ ([a], [a])
                             (case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.<# 0 y) of wild3 {
                                GHC.Types.False -> GHC.Types.[] @ a
                                GHC.Types.True -> GHC.List.$wunsafeTake @ a y wild },
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.<=# y 0) of wild3 {
                                GHC.Types.False -> Helpers.Lists.$wunsafeDrop @ a y wild
                                GHC.Types.True -> wild }) } } } }) -}
b9ae5ddb44d699166745c8646e72ada2
  subSelect ::
    GHC.Types.Int -> [a] -> GHC.Base.Maybe ([a], GHC.Base.Maybe a, [a])
  {- Arity: 2, Strictness: <L,1*U(U)><S,1*U>,
     Unfolding: (\ @ a ds :: GHC.Types.Int ds1 :: [a] ->
                 case ds1 of wild {
                   [] -> GHC.Base.Nothing @ ([a], GHC.Base.Maybe a, [a])
                   : ipv ipv1
                   -> let {
                        ds2 :: ([a], [a])
                        = case Helpers.Lists.subList @ a ds wild of wild1 {
                            GHC.Base.Nothing -> Helpers.Lists.subSelect3 @ a
                            GHC.Base.Just ds3 -> ds3 }
                      } in
                      let {
                        ds3 :: ([a], GHC.Base.Maybe a)
                        = case ds2 of ds4 { (,) taken rest ->
                          case taken of wild1 {
                            [] -> Helpers.Lists.subSelect2 @ a
                            : ds5 ds6
                            -> (GHC.List.init1 @ a ds5 ds6,
                                GHC.Base.Just
                                  @ a
                                  (Helpers.Lists.subSelect1 @ a wild1 (GHC.List.lastError @ a))) } }
                      } in
                      GHC.Base.Just
                        @ ([a], GHC.Base.Maybe a, [a])
                        (case ds3 of wild1 { (,) taken' selected -> taken' },
                         case ds3 of wild1 { (,) taken' selected -> selected },
                         case ds2 of ds4 { (,) taken rest -> rest }) }) -}
ee09413ba56f2295a886f59e2b61eedb
  subSelect1 :: [a] -> a -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
1d01ef20581b02c83c8c854a94d88c3b
  subSelect2 :: ([a], GHC.Base.Maybe a)
  {- HasNoCafRefs,
     Unfolding: (\ @ a -> (GHC.Types.[] @ a, GHC.Base.Nothing @ a)) -}
963cea1019a88d8383c154373ad0661e
  subSelect3 :: ([a], [a])
  {- Strictness: b -}
cb513d40ac60bd761a700adbe26a5107
  takeThrough :: (a -> GHC.Types.Bool) -> [a] -> ([a], [a])
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a w :: a -> GHC.Types.Bool w1 :: [a] ->
                 case Helpers.Lists.$wtakeThrough @ a w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

