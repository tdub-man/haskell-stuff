
==================== FINAL INTERFACE ====================
2016-09-10 20:08:03.538387 UTC

interface pegbo_FGCQSHOeNg054bfGSPqnnE:Helpers.Math 7103
  interface hash: 95f9639280f5db1fe0cca25f7ffc19cc
  ABI hash: 5ee3f5fa6f442eb406772d343c6582af
  export-list hash: b9b8fbc4bfb69b7d6373e638abcf6883
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: b5d1b62220cb540c043dcbd7548cc5a3
  sig of: Nothing
  used TH splices: False
  where
exports:
  Helpers.Math..^
  Helpers.Math.ceilDiv
  Helpers.Math.dist
  Helpers.Math.divTimes
  Helpers.Math.evens
  Helpers.Math.factorial
  Helpers.Math.intSize
  Helpers.Math.odds
  Helpers.Math.squareRoot
  Helpers.Math.squares
  Helpers.Math.triangles
module dependencies:
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  integer-gmp-1.0.0.0:GHC.Integer.Type 371e90fe753f08ddedf0d2657a9ef5c4
6d8cabbf3b190b3b1b6d20bd27e617f3
  (.^) :: GHC.Num.Num a => a -> GHC.Integer.Type.Integer -> a
  {- Arity: 3, Strictness: <L,U(A,A,C(C1(U)),A,A,A,C(U))><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   $dNum :: GHC.Num.Num a
                   x :: a
                   n :: GHC.Integer.Type.Integer ->
                 GHC.Real.^
                   @ a
                   @ GHC.Integer.Type.Integer
                   $dNum
                   GHC.Real.$fIntegralInteger
                   x
                   n) -}
37f12fe35c6e5d223bd3653b00c39ebb
  ceilDiv :: GHC.Real.Integral a => a -> a -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(SLLLLLLLL),U(1*U,A,A,A,1*C1(C1(U)),1*C1(C1(U)),A,A,A)><L,U><L,U>,
     Unfolding: (\ @ a
                   $dIntegral :: GHC.Real.Integral a
                   eta :: a
                   eta1 :: a ->
                 let {
                   $dReal :: GHC.Real.Real a = GHC.Real.$p1Integral @ a $dIntegral
                 } in
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Real @ a $dReal
                 } in
                 case GHC.Classes.==
                        @ a
                        (GHC.Classes.$p1Ord @ a (GHC.Real.$p2Real @ a $dReal))
                        (GHC.Real.mod @ a $dIntegral eta eta1)
                        (GHC.Num.fromInteger @ a $dNum Helpers.Math.ceilDiv2) of wild {
                   GHC.Types.False
                   -> GHC.Num.+
                        @ a
                        $dNum
                        (GHC.Real.div @ a $dIntegral eta eta1)
                        (GHC.Num.fromInteger @ a $dNum Helpers.Math.ceilDiv1)
                   GHC.Types.True -> GHC.Real.div @ a $dIntegral eta eta1 }) -}
114bc10d98487834e5e8727e39abbbb0
  ceilDiv1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 1) -}
0e146a89fccde8772b4d29b6dc1f33e8
  ceilDiv2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 0) -}
92cc20223cbd424488d462585baeaf27
  dist :: GHC.Num.Num a => a -> a -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLLC(S)LL),U(A,1*C1(C1(U)),A,A,1*C1(U),A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a $dNum :: GHC.Num.Num a a1 :: a b :: a ->
                 GHC.Num.abs @ a $dNum (GHC.Num.- @ a $dNum a1 b)) -}
c03bcbd1e24fff6dda5011b5c7c7b516
  divTimes :: GHC.Real.Integral a => a -> a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,A,A,A,A,1*C1(U),A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a $dIntegral :: GHC.Real.Integral a x :: a ->
                 let {
                   g :: a -> (a, a) = GHC.Real.divMod @ a $dIntegral x
                 } in
                 \ x1 :: a -> case g x1 of wild { (,) x2 ds1 -> x2 }) -}
9afd5c28a27f094e7b4ee4e6f7a8f079
  evens :: [GHC.Integer.Type.Integer]
  {- Unfolding: (GHC.Enum.enumDeltaIntegerFB
                   @ [GHC.Integer.Type.Integer]
                   Helpers.Math.evens1
                   Helpers.Math.ceilDiv1
                   Helpers.Math.ceilDiv1) -}
1d2ba8971268992fe6daad7e6e03f9f4
  evens1 ::
    GHC.Integer.Type.Integer
    -> [GHC.Integer.Type.Integer] -> [GHC.Integer.Type.Integer]
  {- Arity: 2,
     Unfolding: (\ x :: GHC.Integer.Type.Integer
                   ys :: [GHC.Integer.Type.Integer][OneShot] ->
                 GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   (GHC.Integer.Type.timesInteger Helpers.Math.evens2 x)
                   ys) -}
440ddad846bd1276d9251d91437c60b2
  evens2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 2) -}
8304ffe4b90038d52d4b2ab3b532ff3f
  factorial :: GHC.Real.Integral a => a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLLLL),1*U(1*U,A,A,A,A,A,A,A,A)><L,U>,
     Unfolding: (\ @ a $dIntegral :: GHC.Real.Integral a eta :: a ->
                 let {
                   $dReal :: GHC.Real.Real a = GHC.Real.$p1Integral @ a $dIntegral
                 } in
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Real @ a $dReal
                 } in
                 let {
                   $dOrd :: GHC.Classes.Ord a = GHC.Real.$p2Real @ a $dReal
                 } in
                 let {
                   $dEq :: GHC.Classes.Eq a = GHC.Classes.$p1Ord @ a $dOrd
                 } in
                 case GHC.Classes.==
                        @ a
                        $dEq
                        eta
                        (GHC.Num.fromInteger @ a $dNum Helpers.Math.ceilDiv2) of wild {
                   GHC.Types.False
                   -> let {
                        lvl3 :: a = GHC.Num.fromInteger @ a $dNum Helpers.Math.ceilDiv1
                      } in
                      let {
                        lvl4 :: a = GHC.Num.fromInteger @ a $dNum Helpers.Math.ceilDiv2
                      } in
                      letrec {
                        $wfactHelp :: a -> a -> (# a, GHC.Integer.Type.Integer #)
                          {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0] -}
                        = \ ww :: a ww1 :: a ->
                          case GHC.Classes.== @ a $dEq ww1 lvl4 of wild1 {
                            GHC.Types.False
                            -> $wfactHelp
                                 (GHC.Num.* @ a $dNum ww ww1)
                                 (GHC.Num.- @ a $dNum ww1 lvl3)
                            GHC.Types.True -> (# ww, Helpers.Math.ceilDiv2 #) }
                      } in
                      case $wfactHelp lvl3 eta of ww { (#,#) ww1 ww2 -> ww1 }
                   GHC.Types.True
                   -> GHC.Num.fromInteger @ a $dNum Helpers.Math.ceilDiv1 }) -}
a70f5446804605e1bc743f0e8267ce8d
  intSize :: GHC.Real.Integral a => a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLLLLLL),U(U,A,A,A,C(C1(U)),A,A,A,A)><L,U>,
     Unfolding: (\ @ a $dIntegral :: GHC.Real.Integral a eta :: a ->
                 let {
                   $dReal :: GHC.Real.Real a = GHC.Real.$p1Integral @ a $dIntegral
                 } in
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Real @ a $dReal
                 } in
                 case GHC.Classes.==
                        @ a
                        (GHC.Classes.$p1Ord @ a (GHC.Real.$p2Real @ a $dReal))
                        eta
                        (GHC.Num.fromInteger @ a $dNum Helpers.Math.ceilDiv2) of wild {
                   GHC.Types.False
                   -> let {
                        lvl3 :: a = GHC.Num.fromInteger @ a $dNum Helpers.Math.ceilDiv2
                      } in
                      let {
                        lvl4 :: a = GHC.Num.fromInteger @ a $dNum Helpers.Math.ceilDiv1
                      } in
                      let {
                        a1 :: GHC.Classes.Ord a = GHC.Real.$p2Real @ a $dReal
                      } in
                      let {
                        $dEq :: GHC.Classes.Eq a = GHC.Classes.$p1Ord @ a a1
                      } in
                      let {
                        lvl5 :: a = GHC.Num.fromInteger @ a $dNum Helpers.Math.intSize1
                      } in
                      letrec {
                        $wsizeHelp :: a -> a -> (# a, GHC.Integer.Type.Integer #)
                          {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0] -}
                        = \ ww :: a ww1 :: a ->
                          case GHC.Classes.== @ a $dEq ww1 lvl3 of wild1 {
                            GHC.Types.False
                            -> $wsizeHelp
                                 (GHC.Num.+ @ a $dNum ww lvl4)
                                 (GHC.Real.div @ a $dIntegral ww1 lvl5)
                            GHC.Types.True -> (# ww, Helpers.Math.ceilDiv2 #) }
                      } in
                      case $wsizeHelp lvl3 eta of ww { (#,#) ww1 ww2 -> ww1 }
                   GHC.Types.True
                   -> GHC.Num.fromInteger @ a $dNum Helpers.Math.ceilDiv1 }) -}
2369445efc63ad32bcf723e858c92e39
  intSize1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 10) -}
a198bd172fd4f0731cb64f828a1308fe
  odds :: [GHC.Integer.Type.Integer]
  {- Unfolding: (GHC.Enum.enumDeltaIntegerFB
                   @ [GHC.Integer.Type.Integer]
                   Helpers.Math.odds1
                   Helpers.Math.ceilDiv1
                   Helpers.Math.ceilDiv1) -}
567995d0c96737f3c6e869018fd270a0
  odds1 ::
    GHC.Integer.Type.Integer
    -> [GHC.Integer.Type.Integer] -> [GHC.Integer.Type.Integer]
  {- Arity: 2,
     Unfolding: (\ x :: GHC.Integer.Type.Integer
                   ys :: [GHC.Integer.Type.Integer][OneShot] ->
                 GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   (GHC.Integer.Type.minusInteger
                      (GHC.Integer.Type.timesInteger Helpers.Math.evens2 x)
                      Helpers.Math.ceilDiv1)
                   ys) -}
85cd340f1696b910f4cd49d25bcce093
  squareRoot :: GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
  {- Arity: 1, Strictness: <S,U> -}
edf4f2c8b6bc6adcd3e6950f5c4643d8
  squares :: [GHC.Integer.Type.Integer]
  {- Unfolding: (GHC.Enum.enumDeltaIntegerFB
                   @ [GHC.Integer.Type.Integer]
                   Helpers.Math.squares1
                   Helpers.Math.ceilDiv1
                   Helpers.Math.ceilDiv1) -}
e2ba10b90c17a2cb49b519e0d6692e77
  squares1 ::
    GHC.Integer.Type.Integer
    -> [GHC.Integer.Type.Integer] -> [GHC.Integer.Type.Integer]
  {- Arity: 2,
     Unfolding: (\ x :: GHC.Integer.Type.Integer
                   ys :: [GHC.Integer.Type.Integer][OneShot] ->
                 GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   (GHC.Integer.Type.timesInteger x x)
                   ys) -}
63275cdfef290138a554ad7a24296676
  triangles :: [GHC.Integer.Type.Integer]
  {- Unfolding: (case GHC.Enum.$wenumDeltaInteger
                        Helpers.Math.ceilDiv1
                        Helpers.Math.ceilDiv1 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.:
                   @ GHC.Integer.Type.Integer
                   ww1
                   (case GHC.List.$wscanlGo
                           @ GHC.Integer.Type.Integer
                           @ GHC.Integer.Type.Integer
                           @ GHC.Integer.Type.Integer
                           @ GHC.Integer.Type.Integer
                           GHC.Integer.Type.plusInteger
                           ww1
                           ww2 of ww4 { (#,#) ww5 ww6 ->
                    ww6 }) }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

