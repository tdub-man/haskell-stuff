
==================== FINAL INTERFACE ====================
2016-10-28 16:45:04.397276 UTC

interface pegboard-0.1.0.0-FjeDzkb0etYsOVuQKSaT2:PegBoard 8001
  interface hash: 4b4a277830c6eed0818f25fa60db95e9
  ABI hash: f83d3917c805320b9d1eddcc14783c79
  export-list hash: 019cb6a33f1bb6c7b9bb5da6116f70e8
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: b159a15c55fa7c6870cb2eb79bbae5a5
  sig of: Nothing
  used TH splices: False
  where
exports:
  PegBoard.addPeg
  PegBoard.makeBoard
  PegBoard.pegCount
  PegBoard.removePeg
  PegBoard.showBoard
  PegBoard.Board{PegBoard.Board}
  PegBoard.Coord{PegBoard.Coord}
module dependencies: Helpers.Lists
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:Data.Foldable 8aeb682f6c74f97fcf0ace0d608a43ea
import  -/  base-4.9.0.0:Data.List 49b86831b79b49ce5d4d9416ecba61df
import  -/  base-4.9.0.0:Data.OldList 0058409f994fb13ae0616e3f1e5b4dae
import  -/  base-4.9.0.0:Data.Tuple acb0ed10307ed88df6c81b8589f4de16
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.List 13d2451194c1c6e53b4f4f07947736dd
import  -/  base-4.9.0.0:GHC.Num 48f506a8f4ecf06285d0a0706594dcc0
import  -/  base-4.9.0.0:GHC.Read 817c914615ac8e308afc0c675fb3f671
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  base-4.9.0.0:Text.Read 9c1be14f7e5eac8b18bcb566c5763677
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  Helpers.Lists 9c52ca015466111e8d572aeb56cfef86
  exports: 975c27250cc63b29bcdfa4d36e613251
  groupWithNs b1022a27f57a046ff09486b043ef777b
  moveXTo 0478e9ef0700120cd4c7a855d902d411
  takeThrough 071c2b178497647d5209e5386195bffb
c47801c17d6fbde18b84e473ce510507
  $fEqBoard :: GHC.Classes.Eq PegBoard.Board
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PegBoard.Board PegBoard.$fEqBoard_$c== PegBoard.$fEqBoard_$c/= -}
c47801c17d6fbde18b84e473ce510507
  $fEqBoard_$c/= ::
    PegBoard.Board -> PegBoard.Board -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: PegBoard.Board) (b :: PegBoard.Board) ->
                 case PegBoard.$fEqBoard_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
c47801c17d6fbde18b84e473ce510507
  $fEqBoard_$c== ::
    PegBoard.Board -> PegBoard.Board -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: PegBoard.Board) (w1 :: PegBoard.Board) ->
                 case w of ww { PegBoard.Board ww1 ww2 ->
                 case w1 of ww3 { PegBoard.Board ww4 ww5 ->
                 PegBoard.$w$c== ww1 ww2 ww4 ww5 } }) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fEqCoord :: GHC.Classes.Eq PegBoard.Coord
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PegBoard.Coord PegBoard.$fEqCoord_$c== PegBoard.$fEqCoord_$c/= -}
175aeaab41cec97be39a9c7cdcc5b317
  $fEqCoord_$c/= ::
    PegBoard.Coord -> PegBoard.Coord -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: PegBoard.Coord) (w1 :: PegBoard.Coord) ->
                 case w of ww { PegBoard.Coord ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { PegBoard.Coord ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 PegBoard.$w$c/= ww4 ww2 ww9 ww7 } } } }) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fEqCoord_$c== ::
    PegBoard.Coord -> PegBoard.Coord -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: PegBoard.Coord) (w1 :: PegBoard.Coord) ->
                 case w of ww { PegBoard.Coord ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { PegBoard.Coord ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 PegBoard.$w$c==1 ww4 ww2 ww9 ww7 } } } }) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fOrdCoord :: GHC.Classes.Ord PegBoard.Coord
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PegBoard.Coord
                  PegBoard.$fEqCoord
                  PegBoard.$fOrdCoord_$ccompare
                  PegBoard.$fOrdCoord_$c<
                  PegBoard.$fOrdCoord_$c<=
                  PegBoard.$fOrdCoord_$c>
                  PegBoard.$fOrdCoord_$c>=
                  PegBoard.$fOrdCoord_$cmax
                  PegBoard.$fOrdCoord_$cmin -}
175aeaab41cec97be39a9c7cdcc5b317
  $fOrdCoord_$c< ::
    PegBoard.Coord -> PegBoard.Coord -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: PegBoard.Coord) (w1 :: PegBoard.Coord) ->
                 case w of ww { PegBoard.Coord ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { PegBoard.Coord ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 PegBoard.$w$c< ww4 ww2 ww9 ww7 } } } }) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fOrdCoord_$c<= ::
    PegBoard.Coord -> PegBoard.Coord -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: PegBoard.Coord) (w1 :: PegBoard.Coord) ->
                 case w of ww { PegBoard.Coord ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { PegBoard.Coord ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 PegBoard.$w$c<= ww4 ww2 ww9 ww7 } } } }) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fOrdCoord_$c> ::
    PegBoard.Coord -> PegBoard.Coord -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: PegBoard.Coord) (w1 :: PegBoard.Coord) ->
                 case w of ww { PegBoard.Coord ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { PegBoard.Coord ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 PegBoard.$w$c> ww4 ww2 ww9 ww7 } } } }) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fOrdCoord_$c>= ::
    PegBoard.Coord -> PegBoard.Coord -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: PegBoard.Coord) (w1 :: PegBoard.Coord) ->
                 case w of ww { PegBoard.Coord ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { PegBoard.Coord ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 PegBoard.$w$c>= ww4 ww2 ww9 ww7 } } } }) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fOrdCoord_$ccompare ::
    PegBoard.Coord -> PegBoard.Coord -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: PegBoard.Coord) (w1 :: PegBoard.Coord) ->
                 case w of ww { PegBoard.Coord ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { PegBoard.Coord ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 PegBoard.$w$ccompare ww4 ww2 ww9 ww7 } } } }) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fOrdCoord_$cmax ::
    PegBoard.Coord -> PegBoard.Coord -> PegBoard.Coord
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(U(U),U(U))><S(S(S)L),1*U(U(U),U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: PegBoard.Coord) (w1 :: PegBoard.Coord) ->
                 case w of ww { PegBoard.Coord ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { PegBoard.Coord ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww4 ww9) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww4 ww9) of wild1 {
                        GHC.Types.False -> PegBoard.Coord (GHC.Types.I# ww4) ww2
                        GHC.Types.True
                        -> case ww2 of wild2 { GHC.Types.I# x# ->
                           case ww7 of wild3 { GHC.Types.I# y# ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# x# y#) of wild4 {
                             GHC.Types.False
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# x# y#) of wild5 {
                                  GHC.Types.False -> PegBoard.Coord (GHC.Types.I# ww4) wild2
                                  GHC.Types.True -> PegBoard.Coord (GHC.Types.I# ww9) wild3 }
                             GHC.Types.True -> PegBoard.Coord (GHC.Types.I# ww9) wild3 } } } }
                   GHC.Types.True
                   -> PegBoard.Coord (GHC.Types.I# ww9) ww7 } } } } }) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fOrdCoord_$cmin ::
    PegBoard.Coord -> PegBoard.Coord -> PegBoard.Coord
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(U(U),U(U))><S(S(S)L),1*U(U(U),U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: PegBoard.Coord) (w1 :: PegBoard.Coord) ->
                 case w of ww { PegBoard.Coord ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { PegBoard.Coord ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww4 ww9) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww4 ww9) of wild1 {
                        GHC.Types.False -> PegBoard.Coord (GHC.Types.I# ww9) ww7
                        GHC.Types.True
                        -> case ww2 of wild2 { GHC.Types.I# x# ->
                           case ww7 of wild3 { GHC.Types.I# y# ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# x# y#) of wild4 {
                             GHC.Types.False
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# x# y#) of wild5 {
                                  GHC.Types.False -> PegBoard.Coord (GHC.Types.I# ww9) wild3
                                  GHC.Types.True -> PegBoard.Coord (GHC.Types.I# ww4) wild2 }
                             GHC.Types.True -> PegBoard.Coord (GHC.Types.I# ww4) wild2 } } } }
                   GHC.Types.True
                   -> PegBoard.Coord (GHC.Types.I# ww4) ww2 } } } } }) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fReadCoord :: GHC.Read.Read PegBoard.Coord
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PegBoard.Coord
                  PegBoard.$fReadCoord_$creadsPrec
                  PegBoard.$fReadCoord_$creadList
                  PegBoard.$fReadCoord_$creadPrec
                  PegBoard.$fReadCoord_$creadListPrec -}
175aeaab41cec97be39a9c7cdcc5b317
  $fReadCoord1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([PegBoard.Coord] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>m2,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [PegBoard.Coord] -> Text.ParserCombinators.ReadP.P b) ->
                 case Text.ParserCombinators.ReadP.$wreadS_to_P
                        @ [PegBoard.Coord]
                        PegBoard.$fReadCoord_$creadList
                        @ b
                        eta1 of ww { Unit# ww1 ->
                 Text.ParserCombinators.ReadP.Look @ b ww1 }) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fReadCoord2 :: Text.ParserCombinators.ReadP.P [PegBoard.Coord]
  {- Unfolding: (GHC.Read.$wlist
                   @ PegBoard.Coord
                   PegBoard.$fReadCoord3
                     `cast`
                   (Trans
                        (<Text.ParserCombinators.ReadPrec.Prec>_R
                         ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                       <PegBoard.Coord>_R))
                        (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                  <PegBoard.Coord>_R)))
                   @ [PegBoard.Coord]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [PegBoard.Coord])) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fReadCoord3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (PegBoard.Coord -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,A><L,C(U)>m2,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: PegBoard.Coord -> Text.ParserCombinators.ReadP.P b) ->
                 case Text.ParserCombinators.ReadP.$wreadS_to_P
                        @ PegBoard.Coord
                        (PegBoard.$fReadCoord_$creadsPrec eta)
                        @ b
                        eta1 of ww { Unit# ww1 ->
                 Text.ParserCombinators.ReadP.Look @ b ww1 }) -}
e4a7b838c5de2bec411386fb63da26e2
  $fReadCoord4 :: (GHC.Types.Int, GHC.Types.Int)
  {- Strictness: x -}
0f88d6b709877a253abf7e1a285ee77a
  $fReadCoord5 :: (GHC.Types.Int, GHC.Types.Int)
  {- Strictness: x -}
90b9e4676eed430c508257838903180c
  $fReadCoord6 ::
    Text.ParserCombinators.ReadP.P (GHC.Types.Int, GHC.Types.Int)
  {- Unfolding: (GHC.Read.$w$creadPrec
                   @ GHC.Types.Int
                   @ GHC.Types.Int
                   GHC.Read.$fReadInt
                   GHC.Read.$fReadInt
                   @ (GHC.Types.Int, GHC.Types.Int)
                   (Text.Read.readEither5 @ (GHC.Types.Int, GHC.Types.Int))) -}
347dd8a16dc5faadfb0985020f5da48c
  $fReadCoord7 :: GHC.Types.Char -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: GHC.Types.Char) ->
                 case ds of wild { GHC.Types.C# x2 ->
                 case x2 of wild1 {
                   DEFAULT -> GHC.Types.True ')'# -> GHC.Types.False } }) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fReadCoord_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [PegBoard.Coord]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [PegBoard.Coord]
                   PegBoard.$fReadCoord2) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fReadCoord_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [PegBoard.Coord]
  {- Arity: 2, Strictness: <L,A><L,C(U)>m2,
     Unfolding: InlineRule (0, True, True)
                PegBoard.$fReadCoord1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[PegBoard.Coord]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[PegBoard.Coord]>_R))) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fReadCoord_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec PegBoard.Coord
  {- Arity: 2, Strictness: <L,A><L,C(U)>m2,
     Unfolding: InlineRule (0, True, True)
                PegBoard.$fReadCoord3
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <PegBoard.Coord>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <PegBoard.Coord>_R))) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fReadCoord_$creadsPrec ::
    GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS PegBoard.Coord
  {- Arity: 2, Strictness: <L,A><L,1*U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: GHC.Base.String) ->
                 case PegBoard.$w$creadsPrec w1 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ (PegBoard.Coord, GHC.Base.String) ww1 ww2 }) -}
c47801c17d6fbde18b84e473ce510507
  $fShowBoard :: GHC.Show.Show PegBoard.Board
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PegBoard.Board
                  PegBoard.$fShowBoard_$cshowsPrec
                  PegBoard.$fShowBoard_$cshow
                  PegBoard.$fShowBoard_$cshowList -}
c47801c17d6fbde18b84e473ce510507
  $fShowBoard1 ::
    PegBoard.Board -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ (x2 :: PegBoard.Board)
                   (s :: GHC.Base.String)[OneShot] ->
                 case x2 of ww { PegBoard.Board ww1 ww2 ->
                 GHC.Base.++ @ GHC.Types.Char (PegBoard.$w$cshow ww1 ww2) s }) -}
90233cd8e58c447d1558b2578f659950
  $fShowBoard2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " }"#) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fShowBoard3 ::
    PegBoard.Coord -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (\ (x2 :: PegBoard.Coord)
                   (s :: GHC.Base.String)[OneShot] ->
                 case x2 of wild { PegBoard.Coord x3 y ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.:
                      @ GHC.Types.Char
                      GHC.Show.shows9
                      (case x3 of ww2 { GHC.Types.I# ww3 ->
                       case GHC.Show.$wshowSignedInt
                              0#
                              ww3
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.shows7
                                 (GHC.Show.$fShow(,)_$sgo
                                    PegBoard.$fShowBoard4
                                    (\ (w2 :: GHC.Base.String) ->
                                     case y of ww1 { GHC.Types.I# ww5 ->
                                     case GHC.Show.$wshowSignedInt
                                            0#
                                            ww5
                                            w2 of ww4 { (#,#) ww6 ww7 ->
                                     GHC.Types.: @ GHC.Types.Char ww6 ww7 } })
                                    (GHC.Types.[] @ GHC.Show.ShowS))) of ww4 { (#,#) ww5 ww6 ->
                       GHC.Types.: @ GHC.Types.Char ww5 ww6 } }))
                   s }) -}
1e7dc63b3ffc5468160f94a19a054177
  $fShowBoard4 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows6
                   (GHC.Types.[] @ GHC.Types.Char)) -}
c47801c17d6fbde18b84e473ce510507
  $fShowBoard_$cshow :: PegBoard.Board -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: PegBoard.Board) ->
                 case w of ww { PegBoard.Board ww1 ww2 ->
                 PegBoard.$w$cshow ww1 ww2 }) -}
c47801c17d6fbde18b84e473ce510507
  $fShowBoard_$cshowList :: [PegBoard.Board] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ls :: [PegBoard.Board]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ PegBoard.Board PegBoard.$fShowBoard1 ls s) -}
c47801c17d6fbde18b84e473ce510507
  $fShowBoard_$cshowsPrec ::
    GHC.Types.Int -> PegBoard.Board -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U(1*U,1*U)><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x2 :: PegBoard.Board)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (PegBoard.$fShowBoard_$cshow x2))
                   s) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fShowCoord :: GHC.Show.Show PegBoard.Coord
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PegBoard.Coord
                  PegBoard.$fShowCoord_$cshowsPrec
                  PegBoard.$fShowCoord_$cshow
                  PegBoard.$fShowCoord_$cshowList -}
175aeaab41cec97be39a9c7cdcc5b317
  $fShowCoord_$cshow :: PegBoard.Coord -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(1*U(U),U(U))>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: PegBoard.Coord) ->
                 case w of ww { PegBoard.Coord ww1 ww2 ->
                 case PegBoard.$w$cshow1 ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 GHC.Types.: @ GHC.Types.Char ww4 ww5 } }) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fShowCoord_$cshowList :: [PegBoard.Coord] -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ls :: [PegBoard.Coord]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ PegBoard.Coord PegBoard.$fShowBoard3 ls s) -}
175aeaab41cec97be39a9c7cdcc5b317
  $fShowCoord_$cshowsPrec ::
    GHC.Types.Int -> PegBoard.Coord -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><S,1*U(1*U(U),U(U))><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: PegBoard.Coord)
                   (w2 :: GHC.Base.String) ->
                 case w1 of ww { PegBoard.Coord ww1 ww2 ->
                 PegBoard.$w$cshowsPrec ww1 ww2 w2 }) -}
7ecce7755fa74088db977aa734e8fe06
  $tc'Board :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13174009218089225621##
                   5567578303123992620##
                   PegBoard.$trModule
                   PegBoard.$tc'Board1) -}
ee12e0a3d0dcc7a5ca1cdd25da1e9216
  $tc'Board1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Board"#) -}
dc5c95f162bd51ece00c44d4a05cb88c
  $tc'Coord :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4732059513325648095##
                   5292586436300492725##
                   PegBoard.$trModule
                   PegBoard.$tc'Coord1) -}
11a7671bd98493938fb4e4e789709b17
  $tc'Coord1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Coord"#) -}
effb64d90ca3383f28015ff7c1c2433c
  $tcBoard :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4747664554946209875##
                   13995357841455595106##
                   PegBoard.$trModule
                   PegBoard.$tcBoard1) -}
1c2465cdb0c8704a9e44a63f06e868a3
  $tcBoard1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Board"#) -}
6916a4d827258e83a0a99beb80fbe349
  $tcCoord :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   441190145859914230##
                   551630876275978985##
                   PegBoard.$trModule
                   PegBoard.$tcCoord1) -}
42d7d7c249c4873ae5df3364b7cd0b50
  $tcCoord1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Coord"#) -}
f79179a65d65682c2fa4bb47d4cc58f8
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   PegBoard.$trModule2
                   PegBoard.$trModule1) -}
a858579ef8b83af90f1b746fff5e8b8f
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "PegBoard"#) -}
bb52ca394265def75bfd6d49bf6f43a3
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "pegboard-0.1.0.0-FjeDzkb0etYsOVuQKSaT2"#) -}
98b624f130f2621503f5d6592bc8e93b
  $w$c/= ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.I# x2 ->
                      case ww3 of wild2 { GHC.Types.I# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x2 y) of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
596dc22701b2896dcb0657c7b30f6284
  $w$c< ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww ww2) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww2) of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case ww1 of wild2 { GHC.Types.I# x# ->
                           case ww3 of wild3 { GHC.Types.I# y# ->
                           GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x# y#) } } }
                   GHC.Types.True -> GHC.Types.True }) -}
1e44e4187d8136625804433044e727b7
  $w$c<= ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww ww2) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww2) of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case ww1 of wild2 { GHC.Types.I# x# ->
                           case ww3 of wild3 { GHC.Types.I# y# ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# x# y#) of wild4 {
                             GHC.Types.False
                             -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# x# y#)
                             GHC.Types.True -> GHC.Types.True } } } }
                   GHC.Types.True -> GHC.Types.True }) -}
b71864bc549935417a02e6361a001808
  $w$c== ::
    [PegBoard.Coord]
    -> [PegBoard.Coord]
    -> [PegBoard.Coord]
    -> [PegBoard.Coord]
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: [PegBoard.Coord])
                   (ww1 :: [PegBoard.Coord])
                   (ww2 :: [PegBoard.Coord])
                   (ww3 :: [PegBoard.Coord]) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PegBoard.Coord
                        PegBoard.$fEqCoord
                        ww
                        ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> GHC.Classes.$fEq[]_$c==
                        @ PegBoard.Coord
                        PegBoard.$fEqCoord
                        ww1
                        ww3 }) -}
caea2c7595922ac22fbd72a9010d336e
  $w$c==1 ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Classes.eqInt ww1 ww3 }) -}
3a93254c01d0d885682c5dd98789d012
  $w$c> ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww ww2) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww2) of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True
                        -> case ww1 of wild2 { GHC.Types.I# x# ->
                           case ww3 of wild3 { GHC.Types.I# y# ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# x# y#) of wild4 {
                             GHC.Types.False
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# x# y#) of wild5 {
                                  GHC.Types.False -> GHC.Types.True
                                  GHC.Types.True -> GHC.Types.False }
                             GHC.Types.True -> GHC.Types.False } } } }
                   GHC.Types.True -> GHC.Types.False }) -}
ca0e78b313787c8828351ee4e5067ad1
  $w$c>= ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww ww2) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww2) of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True
                        -> case ww1 of wild2 { GHC.Types.I# x# ->
                           case ww3 of wild3 { GHC.Types.I# y# ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<# x# y#) of wild4 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } } }
                   GHC.Types.True -> GHC.Types.False }) -}
c4e96cf6036a12a27ab88d1854a9c1fa
  $w$ccompare ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Ordering
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# ww ww2) of wild {
                   GHC.Types.False
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# ww ww2) of wild1 {
                        GHC.Types.False -> GHC.Types.GT
                        GHC.Types.True -> GHC.Classes.compareInt ww1 ww3 }
                   GHC.Types.True -> GHC.Types.LT }) -}
175aeaab41cec97be39a9c7cdcc5b317
  $w$creadsPrec ::
    GHC.Base.String
    -> (# (PegBoard.Coord, GHC.Base.String),
          [(PegBoard.Coord, GHC.Base.String)] #)
  {- Arity: 1, Strictness: <L,1*U>, Inline: [0],
     Unfolding: (\ (w :: GHC.Base.String) ->
                 let {
                   ds :: ([GHC.Types.Char], [GHC.Types.Char])
                   = case Helpers.Lists.$wtakeThrough
                            @ GHC.Types.Char
                            PegBoard.$fReadCoord7
                            w of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2) }
                 } in
                 let {
                   ds1 :: (GHC.Types.Int, GHC.Types.Int)
                   = case Text.Read.readEither6
                            @ (GHC.Types.Int, GHC.Types.Int)
                            (Text.ParserCombinators.ReadP.run
                               @ (GHC.Types.Int, GHC.Types.Int)
                               PegBoard.$fReadCoord6
                               (case ds of wild { (,) tup rest -> tup })) of wild {
                       [] -> PegBoard.$fReadCoord5
                       : x2 ds2
                       -> case ds2 of wild1 {
                            [] -> x2 : ipv ipv1 -> PegBoard.$fReadCoord4 } }
                 } in
                 (# (PegBoard.Coord
                       (case ds1 of wild { (,) x2 y -> x2 })
                       (case ds1 of wild { (,) x2 y -> y }),
                     case ds of wild { (,) tup rest -> rest }),
                    GHC.Types.[] @ (PegBoard.Coord, GHC.Base.String) #)) -}
cd8ccb513d342667e9bb8666d512186c
  $w$cshow :: [PegBoard.Coord] -> [PegBoard.Coord] -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: [PegBoard.Coord]) (ww1 :: [PegBoard.Coord]) ->
                 GHC.CString.unpackAppendCString#
                   "{ Pegs-"#
                   (GHC.Base.++
                      @ GHC.Types.Char
                      (GHC.Show.showList__
                         @ PegBoard.Coord
                         PegBoard.$fShowBoard3
                         ww
                         (GHC.Types.[] @ GHC.Types.Char))
                      (GHC.CString.unpackAppendCString#
                         " Holes-"#
                         (GHC.Base.++
                            @ GHC.Types.Char
                            (GHC.Show.showList__
                               @ PegBoard.Coord
                               PegBoard.$fShowBoard3
                               ww1
                               (GHC.Types.[] @ GHC.Types.Char))
                            PegBoard.$fShowBoard2)))) -}
007193ce8a43f4b17d1a7784dfe6e218
  $w$cshow1 ::
    GHC.Types.Int
    -> GHC.Types.Int -> (# GHC.Types.Char, [GHC.Types.Char] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Types.Int) (ww1 :: GHC.Types.Int) ->
                 (# GHC.Show.shows9,
                    case ww of ww2 { GHC.Types.I# ww3 ->
                    case GHC.Show.$wshowSignedInt
                           0#
                           ww3
                           (GHC.Types.:
                              @ GHC.Types.Char
                              GHC.Show.shows7
                              (GHC.Show.$fShow(,)_$sgo
                                 PegBoard.$fShowBoard4
                                 (\ (w2 :: GHC.Base.String) ->
                                  case ww1 of ww5 { GHC.Types.I# ww6 ->
                                  case GHC.Show.$wshowSignedInt 0# ww6 w2 of ww4 { (#,#) ww7 ww8 ->
                                  GHC.Types.: @ GHC.Types.Char ww7 ww8 } })
                                 (GHC.Types.[] @ GHC.Show.ShowS))) of ww4 { (#,#) ww5 ww6 ->
                    GHC.Types.: @ GHC.Types.Char ww5 ww6 } } #)) -}
947ab693eb4c2ebfb3d41216f71e8887
  $w$cshowsPrec ::
    GHC.Types.Int
    -> GHC.Types.Int -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,1*U(U)><L,U(U)><L,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Types.Int)
                   (ww1 :: GHC.Types.Int)
                   (w :: GHC.Base.String) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (GHC.Types.:
                      @ GHC.Types.Char
                      GHC.Show.shows9
                      (case ww of ww2 { GHC.Types.I# ww3 ->
                       case GHC.Show.$wshowSignedInt
                              0#
                              ww3
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.shows7
                                 (GHC.Show.$fShow(,)_$sgo
                                    PegBoard.$fShowBoard4
                                    (\ (w2 :: GHC.Base.String) ->
                                     case ww1 of ww5 { GHC.Types.I# ww6 ->
                                     case GHC.Show.$wshowSignedInt
                                            0#
                                            ww6
                                            w2 of ww4 { (#,#) ww7 ww8 ->
                                     GHC.Types.: @ GHC.Types.Char ww7 ww8 } })
                                    (GHC.Types.[] @ GHC.Show.ShowS))) of ww4 { (#,#) ww5 ww6 ->
                       GHC.Types.: @ GHC.Types.Char ww5 ww6 } }))
                   w) -}
a7993427063ef5643c1d027663d85c2e
  $waddPeg ::
    PegBoard.Coord
    -> [PegBoard.Coord]
    -> [PegBoard.Coord]
    -> (# [PegBoard.Coord], [PegBoard.Coord] #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(U(U),U(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: PegBoard.Coord)
                   (ww :: [PegBoard.Coord])
                   (ww1 :: [PegBoard.Coord]) ->
                 let {
                   ds :: ([PegBoard.Coord], [PegBoard.Coord])
                   = letrec {
                       go1 :: [PegBoard.Coord] -> Data.Monoid.First PegBoard.Coord
                         {- Arity: 1, Strictness: <S,1*U> -}
                       = \ (ds1 :: [PegBoard.Coord]) ->
                         case ds1 of wild {
                           []
                           -> (GHC.Base.Nothing @ PegBoard.Coord)
                                `cast`
                              (Sym (Data.Monoid.N:First[0]) <PegBoard.Coord>_N)
                           : y ys
                           -> case y of wild1 { PegBoard.Coord a1 a2 ->
                              case w of wild2 { PegBoard.Coord b1 b2 ->
                              case a1 of wild3 { GHC.Types.I# x2 ->
                              case b1 of wild4 { GHC.Types.I# y1 ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.==# x2 y1) of wild5 {
                                GHC.Types.False -> go1 ys
                                GHC.Types.True
                                -> case a2 of wild6 { GHC.Types.I# x3 ->
                                   case b2 of wild7 { GHC.Types.I# y2 ->
                                   case GHC.Prim.tagToEnum#
                                          @ GHC.Types.Bool
                                          (GHC.Prim.==# x3 y2) of wild8 {
                                     GHC.Types.False -> go1 ys
                                     GHC.Types.True
                                     -> (GHC.Base.Just @ PegBoard.Coord wild1)
                                          `cast`
                                        (Sym (Data.Monoid.N:First[0]) <PegBoard.Coord>_N) } } } } } } } } }
                     } in
                     case (go1 ww1)
                            `cast`
                          (Data.Monoid.N:First[0] <PegBoard.Coord>_N) of wild {
                       GHC.Base.Nothing -> (ww1, ww)
                       GHC.Base.Just ds1
                       -> (Data.OldList.deleteBy
                             @ PegBoard.Coord
                             PegBoard.$fEqCoord_$c==
                             w
                             ww1,
                           GHC.Types.: @ PegBoard.Coord w ww) }
                 } in
                 (# case ds of wild { (,) hs' ps' -> ps' },
                    case ds of wild { (,) hs' ps' -> hs' } #)) -}
c6e1a61242cac774bd70050dc059d431
  $wmakeBoard ::
    GHC.Types.Int -> (# [PegBoard.Coord], [PegBoard.Coord] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U(U)>, Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Int) ->
                 (# case w of wild1 { GHC.Types.I# y ->
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.># 1# y) of wild {
                      GHC.Types.False
                      -> letrec {
                           go1 :: GHC.Prim.Int# -> [PegBoard.Coord]
                             {- Arity: 1, Strictness: <S,U> -}
                           = \ (x2 :: GHC.Prim.Int#) ->
                             let {
                               n :: [PegBoard.Coord]
                               = case GHC.Prim.tagToEnum#
                                        @ GHC.Types.Bool
                                        (GHC.Prim.==# x2 y) of wild2 {
                                   GHC.Types.False -> go1 (GHC.Prim.+# x2 1#)
                                   GHC.Types.True -> GHC.Types.[] @ PegBoard.Coord }
                             } in
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.># 1# x2) of wild2 {
                               GHC.Types.False
                               -> let {
                                    wild3 :: GHC.Types.Int {- Strictness: m -} = GHC.Types.I# x2
                                  } in
                                  letrec {
                                    go2 :: GHC.Prim.Int# -> [PegBoard.Coord]
                                      {- Arity: 1, Strictness: <L,U> -}
                                    = \ (x3 :: GHC.Prim.Int#) ->
                                      GHC.Types.:
                                        @ PegBoard.Coord
                                        (PegBoard.Coord wild3 (GHC.Types.I# x3))
                                        (case GHC.Prim.tagToEnum#
                                                @ GHC.Types.Bool
                                                (GHC.Prim.==# x3 x2) of wild4 {
                                           GHC.Types.False -> go2 (GHC.Prim.+# x3 1#)
                                           GHC.Types.True -> n })
                                  } in
                                  go2 1#
                               GHC.Types.True -> n }
                         } in
                         go1 1#
                      GHC.Types.True -> GHC.Types.[] @ PegBoard.Coord } },
                    GHC.Types.[] @ PegBoard.Coord #)) -}
6a79da1ee2766d03e5fa71ee1d649835
  $wremovePeg ::
    PegBoard.Coord
    -> [PegBoard.Coord]
    -> [PegBoard.Coord]
    -> (# [PegBoard.Coord], [PegBoard.Coord] #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(U(U),U(U))><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: PegBoard.Coord)
                   (ww :: [PegBoard.Coord])
                   (ww1 :: [PegBoard.Coord]) ->
                 let {
                   ds :: ([PegBoard.Coord], [PegBoard.Coord])
                   = letrec {
                       go1 :: [PegBoard.Coord] -> Data.Monoid.First PegBoard.Coord
                         {- Arity: 1, Strictness: <S,1*U> -}
                       = \ (ds1 :: [PegBoard.Coord]) ->
                         case ds1 of wild {
                           []
                           -> (GHC.Base.Nothing @ PegBoard.Coord)
                                `cast`
                              (Sym (Data.Monoid.N:First[0]) <PegBoard.Coord>_N)
                           : y ys
                           -> case y of wild1 { PegBoard.Coord a1 a2 ->
                              case w of wild2 { PegBoard.Coord b1 b2 ->
                              case a1 of wild3 { GHC.Types.I# x2 ->
                              case b1 of wild4 { GHC.Types.I# y1 ->
                              case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.==# x2 y1) of wild5 {
                                GHC.Types.False -> go1 ys
                                GHC.Types.True
                                -> case a2 of wild6 { GHC.Types.I# x3 ->
                                   case b2 of wild7 { GHC.Types.I# y2 ->
                                   case GHC.Prim.tagToEnum#
                                          @ GHC.Types.Bool
                                          (GHC.Prim.==# x3 y2) of wild8 {
                                     GHC.Types.False -> go1 ys
                                     GHC.Types.True
                                     -> (GHC.Base.Just @ PegBoard.Coord wild1)
                                          `cast`
                                        (Sym (Data.Monoid.N:First[0]) <PegBoard.Coord>_N) } } } } } } } } }
                     } in
                     case (go1 ww)
                            `cast`
                          (Data.Monoid.N:First[0] <PegBoard.Coord>_N) of wild {
                       GHC.Base.Nothing -> (ww, ww1)
                       GHC.Base.Just ds1
                       -> (Data.OldList.deleteBy
                             @ PegBoard.Coord
                             PegBoard.$fEqCoord_$c==
                             w
                             ww,
                           GHC.Types.: @ PegBoard.Coord w ww1) }
                 } in
                 (# case ds of wild { (,) ps' hs' -> ps' },
                    case ds of wild { (,) ps' hs' -> hs' } #)) -}
542b906dc5992aa4266650bf02d3f461
  $wshowBoard ::
    [PegBoard.Coord] -> [PegBoard.Coord] -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0] -}
c47801c17d6fbde18b84e473ce510507
  data Board
    = Board {_pegs :: [PegBoard.Coord], _holes :: [PegBoard.Coord]}
175aeaab41cec97be39a9c7cdcc5b317
  data Coord
    = Coord {_xCoord :: GHC.Types.Int, _yCoord :: GHC.Types.Int}
e1e09a4d7923b885e9118ea0e59ca208
  _holes :: PegBoard.Board -> [PegBoard.Coord]
  RecSel Left PegBoard.Board
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: PegBoard.Board) ->
                 case ds of wild { PegBoard.Board ds1 ds2 -> ds2 }) -}
fff8ed0ccad6a3f91eeabd01f6df6305
  _pegs :: PegBoard.Board -> [PegBoard.Coord]
  RecSel Left PegBoard.Board
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: PegBoard.Board) ->
                 case ds of wild { PegBoard.Board ds1 ds2 -> ds1 }) -}
d156d4d5fa66005a4029c9dfd9e0ebd9
  _xCoord :: PegBoard.Coord -> GHC.Types.Int
  RecSel Left PegBoard.Coord
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: PegBoard.Coord) ->
                 case ds of wild { PegBoard.Coord ds1 ds2 -> ds1 }) -}
dae3bcb6915a4ebaf356dd97dd8b2626
  _yCoord :: PegBoard.Coord -> GHC.Types.Int
  RecSel Left PegBoard.Coord
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: PegBoard.Coord) ->
                 case ds of wild { PegBoard.Coord ds1 ds2 -> ds2 }) -}
a40cccb7891721501344266eaa26c1b3
  addPeg :: PegBoard.Coord -> PegBoard.Board -> PegBoard.Board
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U(U),U(U))><S,1*U(U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: PegBoard.Coord) (w1 :: PegBoard.Board) ->
                 case w1 of ww { PegBoard.Board ww1 ww2 ->
                 case PegBoard.$waddPeg w ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 PegBoard.Board ww4 ww5 } }) -}
36756d6d94bf541cdee1c47f3b41a148
  makeBoard :: GHC.Types.Int -> PegBoard.Board
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case PegBoard.$wmakeBoard w of ww { (#,#) ww1 ww2 ->
                 PegBoard.Board ww1 ww2 }) -}
d5239ba2220de571e91ab26df5e041e6
  pegCount :: PegBoard.Board -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (x2 :: PegBoard.Board) ->
                 case x2 of wild { PegBoard.Board ds ds1 ->
                 case GHC.List.$wlenAcc @ PegBoard.Coord ds 0# of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
8152e4c979462e67a3b476c83d60dac4
  removePeg :: PegBoard.Coord -> PegBoard.Board -> PegBoard.Board
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(U(U),U(U))><S,1*U(U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: PegBoard.Coord) (w1 :: PegBoard.Board) ->
                 case w1 of ww { PegBoard.Board ww1 ww2 ->
                 case PegBoard.$wremovePeg w ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 PegBoard.Board ww4 ww5 } }) -}
16ad6a0417e6222f951276d92ba3344e
  showBoard :: PegBoard.Board -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SL),1*U(1*U,1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: PegBoard.Board) ->
                 case w of ww { PegBoard.Board ww1 ww2 ->
                 PegBoard.$wshowBoard ww1 ww2 }) -}
instance [safe] GHC.Classes.Eq [PegBoard.Board]
  = PegBoard.$fEqBoard
instance [safe] GHC.Classes.Eq [PegBoard.Coord]
  = PegBoard.$fEqCoord
instance [safe] GHC.Classes.Ord [PegBoard.Coord]
  = PegBoard.$fOrdCoord
instance [safe] GHC.Read.Read [PegBoard.Coord]
  = PegBoard.$fReadCoord
instance [safe] GHC.Show.Show [PegBoard.Board]
  = PegBoard.$fShowBoard
instance [safe] GHC.Show.Show [PegBoard.Coord]
  = PegBoard.$fShowCoord
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

