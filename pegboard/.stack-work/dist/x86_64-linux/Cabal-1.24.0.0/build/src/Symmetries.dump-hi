
==================== FINAL INTERFACE ====================
2016-11-02 18:03:19.81402 UTC

interface pegboard-0.1.0.0-FjeDzkb0etYsOVuQKSaT2:Symmetries 8001
  interface hash: e161924b4312cf565e8153f26b0c2d47
  ABI hash: 59509b803e0701c0fd42c318a7f26e01
  export-list hash: f7bc392eb4f8e69204e2fc7af20ed002
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: b159a15c55fa7c6870cb2eb79bbae5a5
  sig of: Nothing
  used TH splices: False
  where
exports:
  Symmetries.boardEquals
  Symmetries.clockRotate
  Symmetries.counterClockRotate
  Symmetries.findSymmetries
  Symmetries.negFlip
  Symmetries.negSymmetric
  Symmetries.posFlip
  Symmetries.posSymmetric
  Symmetries.rotSymmetric
  Symmetries.zedFlip
  Symmetries.zedSymmetric
  Symmetries.Symmetries{Symmetries.All Symmetries.Horizontal Symmetries.Negative Symmetries.Not Symmetries.Positive Symmetries.Rotational}
module dependencies: CriticalPoints Helpers.Lists Helpers.Math
                     PegBoard
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:Data.Foldable 8aeb682f6c74f97fcf0ace0d608a43ea
import  -/  base-4.9.0.0:Data.List 49b86831b79b49ce5d4d9416ecba61df
import  -/  base-4.9.0.0:Data.OldList 0058409f994fb13ae0616e3f1e5b4dae
import  -/  base-4.9.0.0:Data.Tuple acb0ed10307ed88df6c81b8589f4de16
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.List 13d2451194c1c6e53b4f4f07947736dd
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  CriticalPoints af57f81cf1244d8ee38733403d6a3642
  exports: 062caa36d150055fae0d4d8d1aee2142
  bottomRowBR' 119f8b815f92d7e419769266745564a2
  concentricTrianglesExclusive 284642022d08db4238d3541baaebe457
  rows 22e8b7bdc15b58f16589fb2881708686
  toBoolRows 91e7238be23cecdff18f8e5129e176ef
  topLeftRowBR' 8c6d904d79c0a503c102263944248744
  topRightRowBR' 4322e05ed0bbe246a46829dbba529992
import  -/  Helpers.Lists 9c52ca015466111e8d572aeb56cfef86
  exports: 975c27250cc63b29bcdfa4d36e613251
import  -/  PegBoard f83d3917c805320b9d1eddcc14783c79
  exports: 019cb6a33f1bb6c7b9bb5da6116f70e8
  Board 811b281511fb95d934048eb55c0228c6
  Board c47801c17d6fbde18b84e473ce510507
  Coord a7a7404edac42fd75996faf0c0163f41
  Coord 175aeaab41cec97be39a9c7cdcc5b317
1ac38ad02047e86b966c05d03d7a5625
  $fEqSymmetries :: GHC.Classes.Eq Symmetries.Symmetries
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Symmetries.Symmetries
                  Symmetries.$fEqSymmetries_$c==
                  Symmetries.$fEqSymmetries_$c/= -}
1ac38ad02047e86b966c05d03d7a5625
  $fEqSymmetries_$c/= ::
    Symmetries.Symmetries -> Symmetries.Symmetries -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Symmetries.Symmetries)
                   (b :: Symmetries.Symmetries) ->
                 case a of wild {
                   Symmetries.Positive
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Symmetries.Positive -> GHC.Types.False }
                   Symmetries.Horizontal
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Symmetries.Horizontal -> GHC.Types.False }
                   Symmetries.Negative
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Symmetries.Negative -> GHC.Types.False }
                   Symmetries.Rotational
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Symmetries.Rotational -> GHC.Types.False }
                   Symmetries.Not
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Symmetries.Not -> GHC.Types.False }
                   Symmetries.All
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Symmetries.All -> GHC.Types.False } }) -}
1ac38ad02047e86b966c05d03d7a5625
  $fEqSymmetries_$c== ::
    Symmetries.Symmetries -> Symmetries.Symmetries -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Symmetries.Symmetries)
                   (ds1 :: Symmetries.Symmetries) ->
                 case ds of wild {
                   Symmetries.Positive
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Symmetries.Positive -> GHC.Types.True }
                   Symmetries.Horizontal
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Symmetries.Horizontal -> GHC.Types.True }
                   Symmetries.Negative
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Symmetries.Negative -> GHC.Types.True }
                   Symmetries.Rotational
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Symmetries.Rotational -> GHC.Types.True }
                   Symmetries.Not
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Symmetries.Not -> GHC.Types.True }
                   Symmetries.All
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Symmetries.All -> GHC.Types.True } }) -}
1ac38ad02047e86b966c05d03d7a5625
  $fShowSymmetries :: GHC.Show.Show Symmetries.Symmetries
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Symmetries.Symmetries
                  Symmetries.$fShowSymmetries_$cshowsPrec
                  Symmetries.$fShowSymmetries_$cshow
                  Symmetries.$fShowSymmetries_$cshowList -}
9fb6d268388a331907a913024303fe34
  $fShowSymmetries1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "All"#) -}
f1679f1afd63976c90fe18d98c6bafe2
  $fShowSymmetries2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Not"#) -}
d2ef4a82227e123e1e421391357ae378
  $fShowSymmetries3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Rotational"#) -}
57f53a0d881b8f234cec6db6931042be
  $fShowSymmetries4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Negative"#) -}
902f506ac3fda9c235d316d9ae16f5d3
  $fShowSymmetries5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Horizontal"#) -}
8934df41793419b8bfb00040936723ad
  $fShowSymmetries6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Positive"#) -}
1ac38ad02047e86b966c05d03d7a5625
  $fShowSymmetries_$cshow :: Symmetries.Symmetries -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Symmetries.Symmetries) ->
                 Symmetries.$fShowSymmetries_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
1ac38ad02047e86b966c05d03d7a5625
  $fShowSymmetries_$cshowList ::
    [Symmetries.Symmetries] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Symmetries.Symmetries
                   Symmetries.$w$cshowsPrec) -}
1ac38ad02047e86b966c05d03d7a5625
  $fShowSymmetries_$cshowsPrec ::
    GHC.Types.Int -> Symmetries.Symmetries -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Symmetries.Symmetries)
                   (w2 :: GHC.Base.String) ->
                 Symmetries.$w$cshowsPrec w1 w2) -}
a756292dd27108caffdeacc5d9f63d96
  $tc'All :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12763484656807016615##
                   11785679382755413767##
                   Symmetries.$trModule
                   Symmetries.$tc'All1) -}
8e790529c019f87b408cbd246a2e01e5
  $tc'All1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'All"#) -}
3499a6ce0cd2e4a2249a2e84d1d95a24
  $tc'Horizontal :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1247867082036804003##
                   7421588153250848080##
                   Symmetries.$trModule
                   Symmetries.$tc'Horizontal1) -}
9c9e9d108ae788682a259946fff6a539
  $tc'Horizontal1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Horizontal"#) -}
f16de9dfd2a5e91f75a474f3c3b33f39
  $tc'Negative :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17235058719149911408##
                   14073472057471769598##
                   Symmetries.$trModule
                   Symmetries.$tc'Negative1) -}
e4b8762db10cd740cbf18027d4979a4c
  $tc'Negative1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Negative"#) -}
4a06d66f15ddf98f33653bcf56c0ea41
  $tc'Not :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6227956210802228401##
                   3823174137688740503##
                   Symmetries.$trModule
                   Symmetries.$tc'Not1) -}
314672151703b5d3eef1eaf1b6b8a577
  $tc'Not1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Not"#) -}
26878c0201ebce3877ce70f9cf5f5e1a
  $tc'Positive :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3913941090723323543##
                   14268862197761065889##
                   Symmetries.$trModule
                   Symmetries.$tc'Positive1) -}
ee10dd3f0b8b34f4f58dc9ead4ef10d1
  $tc'Positive1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Positive"#) -}
76231a525e2102c4001fc43f6267f92e
  $tc'Rotational :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1382465857622959344##
                   13052487867632220216##
                   Symmetries.$trModule
                   Symmetries.$tc'Rotational1) -}
6d2c01a9fe6d2388c334a7cee71946b1
  $tc'Rotational1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Rotational"#) -}
5208194262589b217ce0fd278da314ea
  $tcSymmetries :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5891910722990328370##
                   12604077837480834675##
                   Symmetries.$trModule
                   Symmetries.$trModule1) -}
0d4b5668eba1e77775d333fdfdc55a8a
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Symmetries.$trModule2
                   Symmetries.$trModule1) -}
8e7c2651a55302fd998d8b2ff598330c
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Symmetries"#) -}
e45b5cb6cf25c0cb8626bcc96d6d840f
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "pegboard-0.1.0.0-FjeDzkb0etYsOVuQKSaT2"#) -}
1ac38ad02047e86b966c05d03d7a5625
  $w$cshowsPrec ::
    Symmetries.Symmetries -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Symmetries.Symmetries)
                   (w1 :: GHC.Base.String) ->
                 case w of wild {
                   Symmetries.Positive
                   -> GHC.Base.++ @ GHC.Types.Char Symmetries.$fShowSymmetries6 w1
                   Symmetries.Horizontal
                   -> GHC.Base.++ @ GHC.Types.Char Symmetries.$fShowSymmetries5 w1
                   Symmetries.Negative
                   -> GHC.Base.++ @ GHC.Types.Char Symmetries.$fShowSymmetries4 w1
                   Symmetries.Rotational
                   -> GHC.Base.++ @ GHC.Types.Char Symmetries.$fShowSymmetries3 w1
                   Symmetries.Not
                   -> GHC.Base.++ @ GHC.Types.Char Symmetries.$fShowSymmetries2 w1
                   Symmetries.All
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Symmetries.$fShowSymmetries1
                        w1 }) -}
2308ec50d1188094eadaba402d9b7a1e
  $wboardEquals ::
    [PegBoard.Coord]
    -> [PegBoard.Coord]
    -> [PegBoard.Coord]
    -> [PegBoard.Coord]
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: [PegBoard.Coord])
                   (ww1 :: [PegBoard.Coord])
                   (ww2 :: [PegBoard.Coord])
                   (ww3 :: [PegBoard.Coord]) ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PegBoard.Coord
                        PegBoard.$fEqCoord
                        (Data.OldList.sortBy
                           @ PegBoard.Coord
                           PegBoard.$fOrdCoord_$ccompare
                           ww)
                        (Data.OldList.sortBy
                           @ PegBoard.Coord
                           PegBoard.$fOrdCoord_$ccompare
                           ww2) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> GHC.Classes.$fEq[]_$c==
                        @ PegBoard.Coord
                        PegBoard.$fEqCoord
                        (Data.OldList.sortBy
                           @ PegBoard.Coord
                           PegBoard.$fOrdCoord_$ccompare
                           ww1)
                        (Data.OldList.sortBy
                           @ PegBoard.Coord
                           PegBoard.$fOrdCoord_$ccompare
                           ww3) }) -}
99ec593f8ce5bfa5b4e79cc992f2c0d3
  $wclockRotate ::
    PegBoard.Board -> (# [PegBoard.Coord], [PegBoard.Coord] #)
  {- Arity: 1, Strictness: <L,1*U(U,U)>, Inline: [0],
     Unfolding: (\ (w :: PegBoard.Board) ->
                 let {
                   concs :: [PegBoard.Board]
                   = case w of ww { PegBoard.Board ww1 ww2 ->
                     case CriticalPoints.$wconcentricTriangles'
                            ww1
                            ww2
                            (GHC.Types.[] @ PegBoard.Board) of ww3 { (#,#) ww4 ww5 ->
                     ww5 } }
                 } in
                 case GHC.Base.map
                        @ PegBoard.Board
                        @ PegBoard.Board
                        Symmetries.rotateRing
                        (GHC.Types.:
                           @ PegBoard.Board
                           (case concs of wild {
                              [] -> GHC.List.badHead @ PegBoard.Board : x ds1 -> x })
                           (Helpers.Lists.compMapR
                              @ PegBoard.Board
                              @ PegBoard.Board
                              CriticalPoints.concentricTrianglesExclusive1
                              concs)) of wild {
                   []
                   -> case GHC.List.foldl2
                      ret_ty (# [PegBoard.Coord], [PegBoard.Coord] #)
                      of {}
                   : x xs
                   -> case x of ww { PegBoard.Board ww1 ww2 ->
                      Symmetries.$wgo xs ww1 ww2 } }) -}
2902ba01783a712d3ad663f3757b0351
  $wfindSymmetries ::
    [PegBoard.Coord] -> [PegBoard.Coord] -> Symmetries.Symmetries
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: [PegBoard.Coord]) (ww1 :: [PegBoard.Coord]) ->
                 let {
                   r :: [Symmetries.Symmetries]
                   = case Symmetries.$wnegSymmetric ww ww1 of wild {
                       DEFAULT
                       -> GHC.Types.:
                            @ Symmetries.Symmetries
                            wild
                            (case Symmetries.$wrotSymmetric ww ww1 of wild1 {
                               DEFAULT
                               -> GHC.Types.:
                                    @ Symmetries.Symmetries
                                    wild1
                                    (GHC.Types.[] @ Symmetries.Symmetries)
                               Symmetries.Not -> GHC.Types.[] @ Symmetries.Symmetries })
                       Symmetries.Not
                       -> case Symmetries.$wrotSymmetric ww ww1 of wild1 {
                            DEFAULT
                            -> GHC.Types.:
                                 @ Symmetries.Symmetries
                                 wild1
                                 (GHC.Types.[] @ Symmetries.Symmetries)
                            Symmetries.Not -> GHC.Types.[] @ Symmetries.Symmetries } }
                 } in
                 case Symmetries.$wposSymmetric ww ww1 of wild {
                   DEFAULT
                   -> case Symmetries.$wzedSymmetric ww ww1 of wild1 {
                        DEFAULT
                        -> case wild of wild2 {
                             DEFAULT -> Symmetries.findSymmetries2
                             Symmetries.Positive
                             -> case wild1 of wild3 {
                                  DEFAULT -> Symmetries.findSymmetries2
                                  Symmetries.Horizontal
                                  -> case r of wild4 {
                                       [] -> Symmetries.findSymmetries2
                                       : ds ds1
                                       -> case ds of wild5 {
                                            DEFAULT -> Symmetries.findSymmetries2
                                            Symmetries.Negative
                                            -> case ds1 of wild6 {
                                                 [] -> Symmetries.findSymmetries2
                                                 : ds2 ds3
                                                 -> case ds2 of wild7 {
                                                      DEFAULT -> Symmetries.findSymmetries2
                                                      Symmetries.Rotational
                                                      -> case ds3 of wild8 {
                                                           [] -> Symmetries.All
                                                           : ipv ipv1
                                                           -> Symmetries.findSymmetries2 } } } } } } }
                        Symmetries.Not -> Symmetries.findSymmetries1 wild r }
                   Symmetries.Not
                   -> case Symmetries.$wzedSymmetric ww ww1 of wild1 {
                        DEFAULT -> Symmetries.findSymmetries1 wild1 r
                        Symmetries.Not
                        -> case r of wild2 {
                             [] -> Symmetries.Not
                             : x ds -> Symmetries.findSymmetries1 x ds } } }) -}
fa3f24a7f1aee14bbbd8347de487a593
  $wgo ::
    [PegBoard.Board]
    -> [PegBoard.Coord]
    -> [PegBoard.Coord]
    -> (# [PegBoard.Coord], [PegBoard.Coord] #)
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U>,
     Inline: [0] -}
59c9ec8993c8710da96fe56c9ce74ebe
  $wnegSymmetric ::
    [PegBoard.Coord] -> [PegBoard.Coord] -> Symmetries.Symmetries
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: [PegBoard.Coord]) (ww1 :: [PegBoard.Coord]) ->
                 case Symmetries.$wclockRotate
                        (case Symmetries.$wclockRotate
                                (case Symmetries.$wclockRotate
                                        (PegBoard.Board ww ww1) of ww2 { (#,#) ww3 ww4 ->
                                 PegBoard.Board ww3 ww4 }) of ww2 { (#,#) ww3 ww4 ->
                         case Symmetries.$wzedFlip ww3 ww4 of ww5 { (#,#) ww6 ww7 ->
                         PegBoard.Board ww6 ww7 } }) of ww2 { (#,#) ww3 ww4 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PegBoard.Coord
                        PegBoard.$fEqCoord
                        (Data.OldList.sortBy
                           @ PegBoard.Coord
                           PegBoard.$fOrdCoord_$ccompare
                           ww)
                        (Data.OldList.sortBy
                           @ PegBoard.Coord
                           PegBoard.$fOrdCoord_$ccompare
                           ww3) of wild {
                   GHC.Types.False -> Symmetries.Not
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ PegBoard.Coord
                             PegBoard.$fEqCoord
                             (Data.OldList.sortBy
                                @ PegBoard.Coord
                                PegBoard.$fOrdCoord_$ccompare
                                ww1)
                             (Data.OldList.sortBy
                                @ PegBoard.Coord
                                PegBoard.$fOrdCoord_$ccompare
                                ww4) of wild1 {
                        GHC.Types.False -> Symmetries.Not
                        GHC.Types.True -> Symmetries.Negative } } }) -}
7c230a781b10194a9224f50247af3e8e
  $wposSymmetric ::
    [PegBoard.Coord] -> [PegBoard.Coord] -> Symmetries.Symmetries
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: [PegBoard.Coord]) (ww1 :: [PegBoard.Coord]) ->
                 case Symmetries.$wclockRotate
                        (case Symmetries.$wclockRotate
                                (case Symmetries.$wclockRotate
                                        (PegBoard.Board ww ww1) of ww2 { (#,#) ww3 ww4 ->
                                 case Symmetries.$wzedFlip ww3 ww4 of ww5 { (#,#) ww6 ww7 ->
                                 PegBoard.Board ww6 ww7 } }) of ww2 { (#,#) ww3 ww4 ->
                         PegBoard.Board ww3 ww4 }) of ww2 { (#,#) ww3 ww4 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PegBoard.Coord
                        PegBoard.$fEqCoord
                        (Data.OldList.sortBy
                           @ PegBoard.Coord
                           PegBoard.$fOrdCoord_$ccompare
                           ww)
                        (Data.OldList.sortBy
                           @ PegBoard.Coord
                           PegBoard.$fOrdCoord_$ccompare
                           ww3) of wild {
                   GHC.Types.False -> Symmetries.Not
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ PegBoard.Coord
                             PegBoard.$fEqCoord
                             (Data.OldList.sortBy
                                @ PegBoard.Coord
                                PegBoard.$fOrdCoord_$ccompare
                                ww1)
                             (Data.OldList.sortBy
                                @ PegBoard.Coord
                                PegBoard.$fOrdCoord_$ccompare
                                ww4) of wild1 {
                        GHC.Types.False -> Symmetries.Not
                        GHC.Types.True -> Symmetries.Positive } } }) -}
4ae44f2c595af1ade70a326570d670d1
  $wrotSymmetric ::
    [PegBoard.Coord] -> [PegBoard.Coord] -> Symmetries.Symmetries
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: [PegBoard.Coord]) (ww1 :: [PegBoard.Coord]) ->
                 case Symmetries.$wclockRotate
                        (PegBoard.Board ww ww1) of ww2 { (#,#) ww3 ww4 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PegBoard.Coord
                        PegBoard.$fEqCoord
                        (Data.OldList.sortBy
                           @ PegBoard.Coord
                           PegBoard.$fOrdCoord_$ccompare
                           ww)
                        (Data.OldList.sortBy
                           @ PegBoard.Coord
                           PegBoard.$fOrdCoord_$ccompare
                           ww3) of wild {
                   GHC.Types.False -> Symmetries.Not
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ PegBoard.Coord
                             PegBoard.$fEqCoord
                             (Data.OldList.sortBy
                                @ PegBoard.Coord
                                PegBoard.$fOrdCoord_$ccompare
                                ww1)
                             (Data.OldList.sortBy
                                @ PegBoard.Coord
                                PegBoard.$fOrdCoord_$ccompare
                                ww4) of wild1 {
                        GHC.Types.False -> Symmetries.Not
                        GHC.Types.True -> Symmetries.Rotational } } }) -}
2153c0044da4db90e2341227bcfe0b70
  $wrotateRing ::
    PegBoard.Board -> (# [PegBoard.Coord], [PegBoard.Coord] #)
  {- Arity: 1, Strictness: <L,U(U,U)>, Inline: [0],
     Unfolding: (\ (w :: PegBoard.Board) ->
                 let {
                   allRows :: [(PegBoard.Coord, GHC.Types.Bool)]
                   = let {
                       ds :: [(PegBoard.Coord, GHC.Types.Bool)]
                       = GHC.List.reverse1
                           @ (PegBoard.Coord, GHC.Types.Bool)
                           (CriticalPoints.topRightRowBR' w)
                           (GHC.Types.[] @ (PegBoard.Coord, GHC.Types.Bool))
                     } in
                     let {
                       ds1 :: CriticalPoints.BoolRow
                       = case w of ww { PegBoard.Board ww1 ww2 ->
                         CriticalPoints.$wtopLeftRowBR' ww1 ww2 }
                     } in
                     let {
                       n :: [(PegBoard.Coord, GHC.Types.Bool)]
                       = let {
                           ds2 :: CriticalPoints.BoolRow
                           = CriticalPoints.bottomRowBR_go
                               (Data.OldList.groupBy
                                  @ (PegBoard.Coord, GHC.Types.Bool)
                                  CriticalPoints.boolRows2
                                  (Data.OldList.sortBy
                                     @ (PegBoard.Coord, GHC.Types.Bool)
                                     CriticalPoints.boolRows1
                                     (CriticalPoints.toBoolRow w)))
                               (GHC.List.lastError @ CriticalPoints.BoolRow)
                         } in
                         let {
                           n1 :: [(PegBoard.Coord, GHC.Types.Bool)]
                           = Symmetries.clockRotate_go2 ds1 ds2
                         } in
                         letrec {
                           go :: [(PegBoard.Coord, GHC.Types.Bool)]
                                 -> [(PegBoard.Coord, GHC.Types.Bool)]
                                 -> [(PegBoard.Coord, GHC.Types.Bool)]
                             {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                           = \ (ds3 :: [(PegBoard.Coord, GHC.Types.Bool)])
                               (eta :: [(PegBoard.Coord, GHC.Types.Bool)]) ->
                             case ds3 of wild {
                               [] -> n1
                               : y ys
                               -> case eta of wild1 {
                                    [] -> n1
                                    : y1 ys1
                                    -> GHC.Types.:
                                         @ (PegBoard.Coord, GHC.Types.Bool)
                                         (case y1 of wild2 { (,) ds4 p ->
                                          (case y of wild3 { (,) x ds5 -> x }, p) })
                                         (go ys ys1) } }
                         } in
                         go ds2 ds
                     } in
                     letrec {
                       go :: [(PegBoard.Coord, GHC.Types.Bool)]
                             -> [(PegBoard.Coord, GHC.Types.Bool)]
                             -> [(PegBoard.Coord, GHC.Types.Bool)]
                         {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                       = \ (ds2 :: [(PegBoard.Coord, GHC.Types.Bool)])
                           (eta :: [(PegBoard.Coord, GHC.Types.Bool)]) ->
                         case ds2 of wild {
                           [] -> n
                           : y ys
                           -> case eta of wild1 {
                                [] -> n
                                : y1 ys1
                                -> GHC.Types.:
                                     @ (PegBoard.Coord, GHC.Types.Bool)
                                     (case y1 of wild2 { (,) ds3 p ->
                                      (case y of wild3 { (,) x ds4 -> x }, p) })
                                     (go ys ys1) } }
                     } in
                     Data.OldList.nubBy
                       @ (PegBoard.Coord, GHC.Types.Bool)
                       Symmetries.clockRotate1
                       (go ds ds1)
                 } in
                 (# Symmetries.clockRotate_go1 allRows,
                    Symmetries.clockRotate_go allRows #)) -}
a86e0344260bbb321e15881b06550c8c
  $wzedFlip ::
    [PegBoard.Coord]
    -> [PegBoard.Coord] -> (# [PegBoard.Coord], [PegBoard.Coord] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: [PegBoard.Coord]) (ww1 :: [PegBoard.Coord]) ->
                 let {
                   newCoords :: [(PegBoard.Coord, GHC.Types.Bool)]
                   = Symmetries.findSymmetries_go2
                       (Data.OldList.groupBy
                          @ PegBoard.Coord
                          CriticalPoints.rows1
                          (Data.OldList.sortBy
                             @ PegBoard.Coord
                             PegBoard.$fOrdCoord_$ccompare
                             (GHC.Base.++ @ PegBoard.Coord ww ww1)))
                       (GHC.Base.map
                          @ [(PegBoard.Coord, GHC.Types.Bool)]
                          @ [(PegBoard.Coord, GHC.Types.Bool)]
                          (GHC.List.reverse @ (PegBoard.Coord, GHC.Types.Bool))
                          (Data.OldList.groupBy
                             @ (PegBoard.Coord, GHC.Types.Bool)
                             CriticalPoints.boolRows2
                             (Data.OldList.sortBy
                                @ (PegBoard.Coord, GHC.Types.Bool)
                                CriticalPoints.boolRows1
                                (CriticalPoints.$wtoBoolRow ww ww1))))
                 } in
                 (# Symmetries.findSymmetries_go1 newCoords,
                    Symmetries.findSymmetries_go newCoords #)) -}
b72f0293b21ec24460d79df2a9a7c0bd
  $wzedSymmetric ::
    [PegBoard.Coord] -> [PegBoard.Coord] -> Symmetries.Symmetries
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: [PegBoard.Coord]) (ww1 :: [PegBoard.Coord]) ->
                 case Symmetries.$wzedFlip ww ww1 of ww2 { (#,#) ww3 ww4 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PegBoard.Coord
                        PegBoard.$fEqCoord
                        (Data.OldList.sortBy
                           @ PegBoard.Coord
                           PegBoard.$fOrdCoord_$ccompare
                           ww)
                        (Data.OldList.sortBy
                           @ PegBoard.Coord
                           PegBoard.$fOrdCoord_$ccompare
                           ww3) of wild {
                   GHC.Types.False -> Symmetries.Not
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ PegBoard.Coord
                             PegBoard.$fEqCoord
                             (Data.OldList.sortBy
                                @ PegBoard.Coord
                                PegBoard.$fOrdCoord_$ccompare
                                ww1)
                             (Data.OldList.sortBy
                                @ PegBoard.Coord
                                PegBoard.$fOrdCoord_$ccompare
                                ww4) of wild1 {
                        GHC.Types.False -> Symmetries.Not
                        GHC.Types.True -> Symmetries.Horizontal } } }) -}
1ac38ad02047e86b966c05d03d7a5625
  data Symmetries
    = Positive | Horizontal | Negative | Rotational | Not | All
370a09b34a88b920274e4d2846aaba2e
  boardEquals :: PegBoard.Board -> PegBoard.Board -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: PegBoard.Board) (w1 :: PegBoard.Board) ->
                 case w of ww { PegBoard.Board ww1 ww2 ->
                 case w1 of ww3 { PegBoard.Board ww4 ww5 ->
                 Symmetries.$wboardEquals ww1 ww2 ww4 ww5 } }) -}
24c3a1a410c54ec9230189b09ec3537d
  clockRotate :: PegBoard.Board -> PegBoard.Board
  {- Arity: 1, Strictness: <L,1*U(U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: PegBoard.Board) ->
                 case Symmetries.$wclockRotate w of ww { (#,#) ww1 ww2 ->
                 PegBoard.Board ww1 ww2 }) -}
c75991a41af9e8118127a1288d7f6f35
  clockRotate1 ::
    (PegBoard.Coord, GHC.Types.Bool)
    -> (PegBoard.Coord, GHC.Types.Bool) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S(S)L)L),1*U(1*U(1*U(U),1*U(U)),A)><S(S(S(S)L)L),1*U(1*U(1*U(U),1*U(U)),A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: (PegBoard.Coord, GHC.Types.Bool))
                   (w1 :: (PegBoard.Coord, GHC.Types.Bool)) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { PegBoard.Coord ww4 ww5 ->
                 case ww4 of ww6 { GHC.Types.I# ww7 ->
                 case w1 of ww8 { (,) ww9 ww10 ->
                 case ww9 of ww11 { PegBoard.Coord ww12 ww13 ->
                 case ww12 of ww14 { GHC.Types.I# ww15 ->
                 PegBoard.$w$c==1 ww7 ww5 ww15 ww13 } } } } } }) -}
2438c57dae4caabcadc96efd328e5e49
  clockRotate_go ::
    [(PegBoard.Coord, GHC.Types.Bool)] -> [PegBoard.Coord]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
18e19db38e473babba5212278208bb34
  clockRotate_go1 ::
    [(PegBoard.Coord, GHC.Types.Bool)] -> [PegBoard.Coord]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
b7870ba495007a2eb2ea274f293a998f
  clockRotate_go2 ::
    [(PegBoard.Coord, GHC.Types.Bool)]
    -> [(PegBoard.Coord, GHC.Types.Bool)]
    -> [(PegBoard.Coord, GHC.Types.Bool)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
5504f545271f813e51e4f64f68858918
  counterClockRotate :: PegBoard.Board -> PegBoard.Board
  {- Arity: 1, Strictness: <L,1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: PegBoard.Board) ->
                 Symmetries.clockRotate (Symmetries.clockRotate x)) -}
cf6b41a18bda35ed49feba3c3f845d7a
  findSymmetries :: PegBoard.Board -> Symmetries.Symmetries
  {- Arity: 1, Strictness: <S(SL),U(U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: PegBoard.Board) ->
                 case w of ww { PegBoard.Board ww1 ww2 ->
                 Symmetries.$wfindSymmetries ww1 ww2 }) -}
bbd46531ce1edee26537fa6cd556fce4
  findSymmetries1 ::
    Symmetries.Symmetries
    -> [Symmetries.Symmetries] -> Symmetries.Symmetries
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Symmetries.Symmetries)[OneShot]
                   (ds :: [Symmetries.Symmetries])[OneShot] ->
                 case ds of wild {
                   [] -> x
                   : ipv ipv1
                   -> case x of wild1 {
                        DEFAULT -> Symmetries.findSymmetries2
                        Symmetries.Positive
                        -> case ipv of wild2 {
                             DEFAULT -> Symmetries.findSymmetries2
                             Symmetries.Horizontal
                             -> case ipv1 of wild3 {
                                  [] -> Symmetries.findSymmetries2
                                  : ds1 ds2
                                  -> case ds1 of wild4 {
                                       DEFAULT -> Symmetries.findSymmetries2
                                       Symmetries.Negative
                                       -> case ds2 of wild5 {
                                            [] -> Symmetries.findSymmetries2
                                            : ds3 ds4
                                            -> case ds3 of wild6 {
                                                 DEFAULT -> Symmetries.findSymmetries2
                                                 Symmetries.Rotational
                                                 -> case ds4 of wild7 {
                                                      [] -> Symmetries.All
                                                      : ipv2 ipv3
                                                      -> Symmetries.findSymmetries2 } } } } } } } }) -}
6860a82f37296821b1d2b19eb3990da7
  findSymmetries2 :: Symmetries.Symmetries
  {- Strictness: x -}
3863719109ae370bd836700ea45abde8
  findSymmetries_go ::
    [(PegBoard.Coord, GHC.Types.Bool)] -> [PegBoard.Coord]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
37b708c9c88fa356a95c006d46a36e8b
  findSymmetries_go1 ::
    [(PegBoard.Coord, GHC.Types.Bool)] -> [PegBoard.Coord]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
4487d24b960f2c2f0178d69b8f06307a
  findSymmetries_go2 ::
    [[PegBoard.Coord]]
    -> [[(PegBoard.Coord, GHC.Types.Bool)]]
    -> [(PegBoard.Coord, GHC.Types.Bool)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
79c9cc5b90b8ec544e121b3a01b7a51b
  negFlip :: PegBoard.Board -> PegBoard.Board
  {- Arity: 1, Strictness: <L,1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: PegBoard.Board) ->
                 Symmetries.clockRotate
                   (Symmetries.zedFlip
                      (Symmetries.clockRotate (Symmetries.clockRotate x)))) -}
24114e4995b9dbbb7cbdf0ffadbd1809
  negSymmetric :: PegBoard.Board -> Symmetries.Symmetries
  {- Arity: 1, Strictness: <S(SL),U(U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: PegBoard.Board) ->
                 case w of ww { PegBoard.Board ww1 ww2 ->
                 Symmetries.$wnegSymmetric ww1 ww2 }) -}
cfe14e41590ed9303434954393daf85a
  posFlip :: PegBoard.Board -> PegBoard.Board
  {- Arity: 1, Strictness: <L,1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: PegBoard.Board) ->
                 Symmetries.clockRotate
                   (Symmetries.clockRotate
                      (Symmetries.zedFlip (Symmetries.clockRotate x)))) -}
d7f4b2116cf59cf107757b39f23c7b88
  posSymmetric :: PegBoard.Board -> Symmetries.Symmetries
  {- Arity: 1, Strictness: <S(SL),U(U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: PegBoard.Board) ->
                 case w of ww { PegBoard.Board ww1 ww2 ->
                 Symmetries.$wposSymmetric ww1 ww2 }) -}
61f3139fed8c1fab3e010584134d1a0e
  rotSymmetric :: PegBoard.Board -> Symmetries.Symmetries
  {- Arity: 1, Strictness: <S(SL),U(U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: PegBoard.Board) ->
                 case w of ww { PegBoard.Board ww1 ww2 ->
                 Symmetries.$wrotSymmetric ww1 ww2 }) -}
4fb3b63da82119ecff49fb77320092c4
  rotateRing :: PegBoard.Board -> PegBoard.Board
  {- Arity: 1, Strictness: <L,U(U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: PegBoard.Board) ->
                 case Symmetries.$wrotateRing w of ww { (#,#) ww1 ww2 ->
                 PegBoard.Board ww1 ww2 }) -}
6402499e37f8605d9cdeeba8d783ebf2
  zedFlip :: PegBoard.Board -> PegBoard.Board
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: PegBoard.Board) ->
                 case w of ww { PegBoard.Board ww1 ww2 ->
                 case Symmetries.$wzedFlip ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 PegBoard.Board ww4 ww5 } }) -}
7e3083bdc4541e9229331fd11b83b7cf
  zedSymmetric :: PegBoard.Board -> Symmetries.Symmetries
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: PegBoard.Board) ->
                 case w of ww { PegBoard.Board ww1 ww2 ->
                 Symmetries.$wzedSymmetric ww1 ww2 }) -}
instance [safe] GHC.Classes.Eq [Symmetries.Symmetries]
  = Symmetries.$fEqSymmetries
instance [safe] GHC.Show.Show [Symmetries.Symmetries]
  = Symmetries.$fShowSymmetries
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

