
==================== FINAL INTERFACE ====================
2016-09-13 00:59:26.428026 UTC

interface pegbo_FGCQSHOeNg054bfGSPqnnE:PegBoardSymmetries 7103
  interface hash: 60a4c834eea666519d7021229e19a0d9
  ABI hash: 48bd86db9f30b9a4d51c921f43a546b3
  export-list hash: 231238971e9dda9bac50c030fad5cdda
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 962af636f8e927040c7daa9c21457292
  sig of: Nothing
  used TH splices: False
  where
exports:
  PegBoardSymmetries.clockRotate
  PegBoardSymmetries.clockSymmetric
  PegBoardSymmetries.counterClockRotate
  PegBoardSymmetries.counterClockSymmetric
  PegBoardSymmetries.findSymmetries
  PegBoardSymmetries.negFlip
  PegBoardSymmetries.negSymmetric
  PegBoardSymmetries.posFlip
  PegBoardSymmetries.posSymmetric
  PegBoardSymmetries.zedFlip
  PegBoardSymmetries.zedSymmetric
  PegBoardSymmetries.Symmetries{PegBoardSymmetries.Clockwise PegBoardSymmetries.CounterClockwise PegBoardSymmetries.Horizontal PegBoardSymmetries.Negative PegBoardSymmetries.Positive}
module dependencies: Helpers.Lists Helpers.Math PegBoard
                     PegBoardCriticalPoints
package dependencies: base-4.8.2.0* ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Monoid
                         base-4.8.2.0:Data.Type.Equality base-4.8.2.0:GHC.Generics
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  Helpers.Lists ef2fe3f1018c91989066bb63b1bab840
  exports: a436165992904039544f32b58c9d6666
import  -/  PegBoard 16a00028148d987bcb0445bcccc4bd0d
  exports: 8ceb9b62cfb26faa219244e1542864dc
  Board b1f9eca28e9b5e676e1b60fc7cfd14a6
  Board fe37fd83b8e4a585ef03d58d782ca831
  Coord 26d14fa8bfea90f28c094a055bef8f1a
import  -/  PegBoardCriticalPoints 92e1d8b968d8882edd9d80e8b22ace7e
  exports: 80a90b048f17dc8146a0ad9d08740776
  bottomRow 803cb8d8d998f497b84f486bfdf1a556
  concentricTrianglesExclusive 17b7eee48e09ae2ca8cf276e7768b1df
  rows 5fd766c55b782da9f79fedb08c890c10
  topLeftRow 6083ae7243539d3531e40a825a3abf36
  topRightRow dab5c488cfd91ca72bb3bc0f07a51c84
353500df914d7ef886eeab3f2102abdd
  $fShowSymmetries :: GHC.Show.Show PegBoardSymmetries.Symmetries
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ PegBoardSymmetries.Symmetries
                  PegBoardSymmetries.$fShowSymmetries_$cshowsPrec
                  PegBoardSymmetries.$fShowSymmetries_$cshow
                  PegBoardSymmetries.$fShowSymmetries_$cshowList -}
353500df914d7ef886eeab3f2102abdd
  $fShowSymmetries1 ::
    PegBoardSymmetries.Symmetries -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (PegBoardSymmetries.$fShowSymmetries_$cshowsPrec
                   PegBoardSymmetries.$fShowSymmetries2) -}
65bd47de0e72ba06cdf66bb62e9d8781
  $fShowSymmetries2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
353500df914d7ef886eeab3f2102abdd
  $fShowSymmetries_$cshow ::
    PegBoardSymmetries.Symmetries -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PegBoardSymmetries.Symmetries ->
                 PegBoardSymmetries.$fShowSymmetries_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
353500df914d7ef886eeab3f2102abdd
  $fShowSymmetries_$cshowList ::
    [PegBoardSymmetries.Symmetries] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ PegBoardSymmetries.Symmetries
                   PegBoardSymmetries.$fShowSymmetries1) -}
353500df914d7ef886eeab3f2102abdd
  $fShowSymmetries_$cshowsPrec ::
    GHC.Types.Int -> PegBoardSymmetries.Symmetries -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U> -}
4a3dc0c63dcf85cde6e15d1e1798d81f
  $wclockRotate ::
    [PegBoard.Coord]
    -> [PegBoard.Coord] -> (# [PegBoard.Coord], [PegBoard.Coord] #)
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: [PegBoard.Coord] ww1 :: [PegBoard.Coord] ->
                 case GHC.Base.map
                        @ PegBoard.Board
                        @ PegBoard.Board
                        PegBoardSymmetries.clockRotate1
                        (PegBoardCriticalPoints.$wconcentricTrianglesExclusive
                           ww
                           ww1) of wild {
                   []
                   -> case GHC.List.foldl2
                      ret_ty (# [PegBoard.Coord], [PegBoard.Coord] #)
                      of {}
                   : x xs
                   -> case x of ww2 { PegBoard.Board ww3 ww4 ->
                      PegBoardSymmetries.$wgo xs ww3 ww4 } }) -}
dbdf4de009deccd052c5d85c81297596
  $wclockSymmetric ::
    [PegBoard.Coord]
    -> [PegBoard.Coord] -> PegBoardSymmetries.Symmetries
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: [PegBoard.Coord] ww1 :: [PegBoard.Coord] ->
                 case PegBoardSymmetries.$wclockRotate
                        ww
                        ww1 of ww2 { (#,#) ww3 ww4 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PegBoard.Coord
                        PegBoard.$fEqCoord
                        ww
                        ww3 of wild {
                   GHC.Types.False -> PegBoardSymmetries.clockSymmetric1
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ PegBoard.Coord
                             PegBoard.$fEqCoord
                             ww1
                             ww4 of wild1 {
                        GHC.Types.False -> PegBoardSymmetries.clockSymmetric1
                        GHC.Types.True -> PegBoardSymmetries.Clockwise } } }) -}
443a0ef3e51883e1dcdc160721a48f51
  $wcounterClockSymmetric ::
    [PegBoard.Coord]
    -> [PegBoard.Coord] -> PegBoardSymmetries.Symmetries
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: [PegBoard.Coord] ww1 :: [PegBoard.Coord] ->
                 case PegBoardSymmetries.$wclockRotate
                        ww
                        ww1 of ww2 { (#,#) ww3 ww4 ->
                 case PegBoardSymmetries.$wclockRotate
                        ww3
                        ww4 of ww5 { (#,#) ww6 ww7 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PegBoard.Coord
                        PegBoard.$fEqCoord
                        ww
                        ww6 of wild {
                   GHC.Types.False -> PegBoardSymmetries.counterClockSymmetric1
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ PegBoard.Coord
                             PegBoard.$fEqCoord
                             ww1
                             ww7 of wild1 {
                        GHC.Types.False -> PegBoardSymmetries.counterClockSymmetric1
                        GHC.Types.True -> PegBoardSymmetries.CounterClockwise } } } }) -}
51360c68156df610d1927e080ef0e998
  $wfindSymmetries ::
    PegBoard.Board
    -> (# PegBoardSymmetries.Symmetries,
          [PegBoardSymmetries.Symmetries] #)
  {- Arity: 1, Strictness: <L,U(U,U)>, Inline: [0],
     Unfolding: (\ w :: PegBoard.Board ->
                 (# PegBoardSymmetries.posSymmetric w,
                    GHC.Types.:
                      @ PegBoardSymmetries.Symmetries
                      (PegBoardSymmetries.zedSymmetric w)
                      (GHC.Types.:
                         @ PegBoardSymmetries.Symmetries
                         (PegBoardSymmetries.negSymmetric w)
                         (GHC.Types.:
                            @ PegBoardSymmetries.Symmetries
                            (PegBoardSymmetries.clockSymmetric w)
                            (GHC.Types.:
                               @ PegBoardSymmetries.Symmetries
                               (PegBoardSymmetries.counterClockSymmetric w)
                               (GHC.Types.[] @ PegBoardSymmetries.Symmetries)))) #)) -}
46aba974f0ca57c2ca029c55b002cd24
  $wgo ::
    [PegBoard.Board]
    -> [PegBoard.Coord]
    -> [PegBoard.Coord]
    -> (# [PegBoard.Coord], [PegBoard.Coord] #)
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U>,
     Inline: [0] -}
2defed5734103e747b4849a7dbba0243
  $wlvl ::
    [PegBoard.Coord]
    -> [PegBoard.Coord] -> (# [PegBoard.Coord], [PegBoard.Coord] #)
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: [PegBoard.Coord] ww1 :: [PegBoard.Coord] ->
                 let {
                   allRows :: [(PegBoard.Coord, GHC.Types.Bool)]
                   = let {
                       a :: [PegBoard.Coord] = PegBoardCriticalPoints.$wtopRightRow ww ww1
                     } in
                     let {
                       a1 :: [PegBoard.Coord] = PegBoardCriticalPoints.$wtopLeftRow ww ww1
                     } in
                     let {
                       isPeg :: PegBoard.Coord -> GHC.Types.Bool
                         {- Arity: 1, Strictness: <L,U>,
                            Unfolding: InlineRule (1, True, False)
                                       (\ ds :: PegBoard.Coord ->
                                        GHC.List.elem @ PegBoard.Coord PegBoard.$fEqCoord ds ww) -}
                       = \ ds :: PegBoard.Coord ->
                         GHC.List.elem @ PegBoard.Coord PegBoard.$fEqCoord ds ww
                     } in
                     let {
                       z :: [(PegBoard.Coord, GHC.Types.Bool)]
                       = let {
                           a2 :: [PegBoard.Coord] = PegBoardCriticalPoints.$wbottomRow ww ww1
                         } in
                         let {
                           z1 :: [(PegBoard.Coord, GHC.Types.Bool)]
                           = GHC.List.zip
                               @ PegBoard.Coord
                               @ GHC.Types.Bool
                               a1
                               (GHC.Base.map @ PegBoard.Coord @ GHC.Types.Bool isPeg a2)
                         } in
                         letrec {
                           go :: [PegBoard.Coord]
                                 -> [GHC.Types.Bool] -> [(PegBoard.Coord, GHC.Types.Bool)]
                             {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                           = \ ds :: [PegBoard.Coord] _ys :: [GHC.Types.Bool] ->
                             case ds of wild {
                               [] -> z1
                               : ipv ipv1
                               -> case _ys of wild1 {
                                    [] -> z1
                                    : ipv2 ipv3
                                    -> GHC.Types.:
                                         @ (PegBoard.Coord, GHC.Types.Bool)
                                         (ipv, ipv2)
                                         (go ipv1 ipv3) } }
                         } in
                         go a2 (GHC.Base.map @ PegBoard.Coord @ GHC.Types.Bool isPeg a)
                     } in
                     letrec {
                       go :: [PegBoard.Coord]
                             -> [GHC.Types.Bool] -> [(PegBoard.Coord, GHC.Types.Bool)]
                         {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                       = \ ds :: [PegBoard.Coord] _ys :: [GHC.Types.Bool] ->
                         case ds of wild {
                           [] -> z
                           : ipv ipv1
                           -> case _ys of wild1 {
                                [] -> z
                                : ipv2 ipv3
                                -> GHC.Types.:
                                     @ (PegBoard.Coord, GHC.Types.Bool)
                                     (ipv, ipv2)
                                     (go ipv1 ipv3) } }
                     } in
                     Data.OldList.nubBy
                       @ (PegBoard.Coord, GHC.Types.Bool)
                       PegBoardSymmetries.clockRotate2
                       (go a (GHC.Base.map @ PegBoard.Coord @ GHC.Types.Bool isPeg a1))
                 } in
                 (# PegBoardSymmetries.clockRotate_go1 allRows,
                    PegBoardSymmetries.clockRotate_go allRows #)) -}
1b451cddb86e91168b617cf24c87abb3
  $wnegSymmetric ::
    [PegBoard.Coord]
    -> [PegBoard.Coord] -> PegBoardSymmetries.Symmetries
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: [PegBoard.Coord] ww1 :: [PegBoard.Coord] ->
                 case PegBoardSymmetries.$wclockRotate
                        ww
                        ww1 of ww2 { (#,#) ww3 ww4 ->
                 case PegBoardSymmetries.$wclockRotate
                        ww3
                        ww4 of ww5 { (#,#) ww6 ww7 ->
                 case PegBoardSymmetries.$wzedFlip
                        ww6
                        ww7 of ww8 { (#,#) ww9 ww10 ->
                 case PegBoardSymmetries.$wclockRotate
                        ww9
                        ww10 of ww11 { (#,#) ww12 ww13 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PegBoard.Coord
                        PegBoard.$fEqCoord
                        ww
                        ww12 of wild {
                   GHC.Types.False -> PegBoardSymmetries.negSymmetric1
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ PegBoard.Coord
                             PegBoard.$fEqCoord
                             ww1
                             ww13 of wild1 {
                        GHC.Types.False -> PegBoardSymmetries.negSymmetric1
                        GHC.Types.True -> PegBoardSymmetries.Negative } } } } } }) -}
ed57f3547a81514d031927df290423f2
  $wposSymmetric ::
    [PegBoard.Coord]
    -> [PegBoard.Coord] -> PegBoardSymmetries.Symmetries
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: [PegBoard.Coord] ww1 :: [PegBoard.Coord] ->
                 case PegBoardSymmetries.$wclockRotate
                        ww
                        ww1 of ww2 { (#,#) ww3 ww4 ->
                 case PegBoardSymmetries.$wzedFlip ww3 ww4 of ww5 { (#,#) ww6 ww7 ->
                 case PegBoardSymmetries.$wclockRotate
                        ww6
                        ww7 of ww8 { (#,#) ww9 ww10 ->
                 case PegBoardSymmetries.$wclockRotate
                        ww9
                        ww10 of ww11 { (#,#) ww12 ww13 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PegBoard.Coord
                        PegBoard.$fEqCoord
                        ww
                        ww12 of wild {
                   GHC.Types.False -> PegBoardSymmetries.posSymmetric1
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ PegBoard.Coord
                             PegBoard.$fEqCoord
                             ww1
                             ww13 of wild1 {
                        GHC.Types.False -> PegBoardSymmetries.posSymmetric1
                        GHC.Types.True -> PegBoardSymmetries.Positive } } } } } }) -}
b627350061202ba1a31f4832da4553ba
  $wzedFlip ::
    [PegBoard.Coord]
    -> [PegBoard.Coord] -> (# [PegBoard.Coord], [PegBoard.Coord] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: [PegBoard.Coord] ww1 :: [PegBoard.Coord] ->
                 let {
                   pshs :: [(PegBoard.Coord, GHC.Types.Bool)]
                   = let {
                       pRows :: [[PegBoard.Coord]]
                       = Data.OldList.groupBy
                           @ PegBoard.Coord
                           PegBoardCriticalPoints.bottomRow1
                           (Data.OldList.sortBy
                              @ PegBoard.Coord
                              PegBoard.$fOrdCoord_$ccompare
                              (GHC.Base.++ @ PegBoard.Coord ww ww1))
                     } in
                     let {
                       a :: PegBoard.Coord -> (PegBoard.Coord, GHC.Types.Bool)
                         {- Arity: 1, Strictness: <L,U>m,
                            Unfolding: InlineRule (1, True, False)
                                       (\ x :: PegBoard.Coord ->
                                        (x,
                                         GHC.List.elem @ PegBoard.Coord PegBoard.$fEqCoord x ww)) -}
                       = \ x :: PegBoard.Coord ->
                         (x, GHC.List.elem @ PegBoard.Coord PegBoard.$fEqCoord x ww)
                     } in
                     letrec {
                       go :: [[PegBoard.Coord]]
                             -> [[PegBoard.Coord]] -> [(PegBoard.Coord, GHC.Types.Bool)]
                         {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                       = \ ds :: [[PegBoard.Coord]] eta :: [[PegBoard.Coord]] ->
                         case ds of wild {
                           [] -> GHC.Types.[] @ (PegBoard.Coord, GHC.Types.Bool)
                           : y ys
                           -> case eta of wild1 {
                                [] -> GHC.Types.[] @ (PegBoard.Coord, GHC.Types.Bool)
                                : y1 ys1
                                -> GHC.Base.++
                                     @ (PegBoard.Coord, GHC.Types.Bool)
                                     (GHC.List.zipWith
                                        @ (PegBoard.Coord, GHC.Types.Bool)
                                        @ PegBoard.Coord
                                        @ (PegBoard.Coord, GHC.Types.Bool)
                                        PegBoardSymmetries.negSymmetric2
                                        (GHC.List.reverse1
                                           @ (PegBoard.Coord, GHC.Types.Bool)
                                           (GHC.Base.map
                                              @ PegBoard.Coord
                                              @ (PegBoard.Coord, GHC.Types.Bool)
                                              a
                                              y)
                                           (GHC.Types.[] @ (PegBoard.Coord, GHC.Types.Bool)))
                                        y1)
                                     (go ys ys1) } }
                     } in
                     go pRows pRows
                 } in
                 (# PegBoardSymmetries.negSymmetric_go1 pshs,
                    PegBoardSymmetries.negSymmetric_go pshs #)) -}
9eba1258f8952d0886bbd27924a3dfe3
  $wzedSymmetric ::
    [PegBoard.Coord]
    -> [PegBoard.Coord] -> PegBoardSymmetries.Symmetries
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: [PegBoard.Coord] ww1 :: [PegBoard.Coord] ->
                 case PegBoardSymmetries.$wzedFlip ww ww1 of ww2 { (#,#) ww3 ww4 ->
                 case GHC.Classes.$fEq[]_$c==
                        @ PegBoard.Coord
                        PegBoard.$fEqCoord
                        ww
                        ww3 of wild {
                   GHC.Types.False -> PegBoardSymmetries.zedSymmetric1
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ PegBoard.Coord
                             PegBoard.$fEqCoord
                             ww1
                             ww4 of wild1 {
                        GHC.Types.False -> PegBoardSymmetries.zedSymmetric1
                        GHC.Types.True -> PegBoardSymmetries.Horizontal } } }) -}
353500df914d7ef886eeab3f2102abdd
  data Symmetries
    = Positive
    | Horizontal
    | Negative
    | Clockwise
    | CounterClockwise
    | Not PegBoardSymmetries.Symmetries
    Promotable
27ea55b3d7c8d68473d4938f73e54a73
  clockRotate :: PegBoard.Board -> PegBoard.Board
  {- Arity: 1, Strictness: <S(SL),1*U(U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PegBoard.Board ->
                 case w of ww { PegBoard.Board ww1 ww2 ->
                 case PegBoardSymmetries.$wclockRotate
                        ww1
                        ww2 of ww3 { (#,#) ww4 ww5 ->
                 PegBoard.Board ww4 ww5 } }) -}
7bd94e90e5c85e728cebe88811416ed7
  clockRotate1 :: PegBoard.Board -> PegBoard.Board
  {- Arity: 1, Strictness: <S,1*U(U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PegBoard.Board ->
                 case w of ww { PegBoard.Board ww1 ww2 ->
                 case PegBoardSymmetries.$wlvl ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 PegBoard.Board ww4 ww5 } }) -}
2e8abb626f3648e5de3e79a773492517
  clockRotate2 ::
    (PegBoard.Coord, GHC.Types.Bool)
    -> (PegBoard.Coord, GHC.Types.Bool) -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SL)L),1*U(1*U(1*U(U),1*U(U)),A)><S(S(SL)L),1*U(1*U(1*U(U),1*U(U)),A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: (PegBoard.Coord, GHC.Types.Bool)
                   w1 :: (PegBoard.Coord, GHC.Types.Bool) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { PegBoard.Coord ww4 ww5 ->
                 case ww4 of ww6 { GHC.Types.I# ww7 ->
                 case w1 of ww8 { (,) ww9 ww10 ->
                 case ww9 of ww11 { PegBoard.Coord ww12 ww13 ->
                 case ww12 of ww14 { GHC.Types.I# ww15 ->
                 PegBoard.$w$c==1 ww7 ww5 ww15 ww13 } } } } } }) -}
3ece1f1c0962d58a560aa272d821edf0
  clockRotate_go ::
    [(PegBoard.Coord, GHC.Types.Bool)] -> [PegBoard.Coord]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
d191a4d9db3d5baad43376a976d1daef
  clockRotate_go1 ::
    [(PegBoard.Coord, GHC.Types.Bool)] -> [PegBoard.Coord]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
08e03661bb7ca774d63f9e298fbb1000
  clockSymmetric :: PegBoard.Board -> PegBoardSymmetries.Symmetries
  {- Arity: 1, Strictness: <S(SL),1*U(U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PegBoard.Board ->
                 case w of ww { PegBoard.Board ww1 ww2 ->
                 PegBoardSymmetries.$wclockSymmetric ww1 ww2 }) -}
f106176e1c6f980cafad86bae8f724f9
  clockSymmetric1 :: PegBoardSymmetries.Symmetries
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (PegBoardSymmetries.Not PegBoardSymmetries.Clockwise) -}
b94300b36f8906caa9e2d5baeb379c7f
  counterClockRotate :: PegBoard.Board -> PegBoard.Board
  {- Arity: 1, Strictness: <S(SL),1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PegBoard.Board ->
                 PegBoardSymmetries.clockRotate
                   (PegBoardSymmetries.clockRotate x)) -}
4182d831f73eb2f73f238f6f9a99ea48
  counterClockSymmetric ::
    PegBoard.Board -> PegBoardSymmetries.Symmetries
  {- Arity: 1, Strictness: <S(SL),1*U(U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PegBoard.Board ->
                 case w of ww { PegBoard.Board ww1 ww2 ->
                 PegBoardSymmetries.$wcounterClockSymmetric ww1 ww2 }) -}
8906691e9a25a87bad9861b58ca9022d
  counterClockSymmetric1 :: PegBoardSymmetries.Symmetries
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (PegBoardSymmetries.Not
                   PegBoardSymmetries.CounterClockwise) -}
156f4c400b50837291b96b1f45c294ba
  findSymmetries :: PegBoard.Board -> [PegBoardSymmetries.Symmetries]
  {- Arity: 1, Strictness: <L,U(U,U)>m2, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PegBoard.Board ->
                 case PegBoardSymmetries.$wfindSymmetries w of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ PegBoardSymmetries.Symmetries ww1 ww2 }) -}
e627a3bc9e828bdf042cfd271e6fec6f
  negFlip :: PegBoard.Board -> PegBoard.Board
  {- Arity: 1, Strictness: <S(SL),1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PegBoard.Board ->
                 PegBoardSymmetries.clockRotate
                   (PegBoardSymmetries.zedFlip
                      (PegBoardSymmetries.clockRotate
                         (PegBoardSymmetries.clockRotate x)))) -}
c3fd3b7c4fc78cbd476960d3d55eea53
  negSymmetric :: PegBoard.Board -> PegBoardSymmetries.Symmetries
  {- Arity: 1, Strictness: <S(SL),1*U(U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PegBoard.Board ->
                 case w of ww { PegBoard.Board ww1 ww2 ->
                 PegBoardSymmetries.$wnegSymmetric ww1 ww2 }) -}
b4220765b69eecd2f4154cd6737ee790
  negSymmetric1 :: PegBoardSymmetries.Symmetries
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (PegBoardSymmetries.Not PegBoardSymmetries.Negative) -}
08c6d5fa5fa9c206d2e144d56de7d59f
  negSymmetric2 ::
    (PegBoard.Coord, GHC.Types.Bool)
    -> PegBoard.Coord -> (PegBoard.Coord, GHC.Types.Bool)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(A,U)><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: (PegBoard.Coord, GHC.Types.Bool) c :: PegBoard.Coord ->
                 case ds of wild { (,) ds1 p -> (c, p) }) -}
7521421bcb829be8d1121cda3ddc8704
  negSymmetric_go ::
    [(PegBoard.Coord, GHC.Types.Bool)] -> [PegBoard.Coord]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
c39546c2a9ac3dfa357a880d31720ba3
  negSymmetric_go1 ::
    [(PegBoard.Coord, GHC.Types.Bool)] -> [PegBoard.Coord]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
ea9895b01016a9480db271a0ec4f9da2
  posFlip :: PegBoard.Board -> PegBoard.Board
  {- Arity: 1, Strictness: <S(SL),1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ x :: PegBoard.Board ->
                 PegBoardSymmetries.clockRotate
                   (PegBoardSymmetries.clockRotate
                      (PegBoardSymmetries.zedFlip
                         (PegBoardSymmetries.clockRotate x)))) -}
30ba006acbc9c66928d0afb14930b5f8
  posSymmetric :: PegBoard.Board -> PegBoardSymmetries.Symmetries
  {- Arity: 1, Strictness: <S(SL),1*U(U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PegBoard.Board ->
                 case w of ww { PegBoard.Board ww1 ww2 ->
                 PegBoardSymmetries.$wposSymmetric ww1 ww2 }) -}
63d57f724826dccad56528d1f5baba52
  posSymmetric1 :: PegBoardSymmetries.Symmetries
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (PegBoardSymmetries.Not PegBoardSymmetries.Positive) -}
b37bacec67bc88fe014996ae8c3a3344
  zedFlip :: PegBoard.Board -> PegBoard.Board
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PegBoard.Board ->
                 case w of ww { PegBoard.Board ww1 ww2 ->
                 case PegBoardSymmetries.$wzedFlip ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 PegBoard.Board ww4 ww5 } }) -}
eb7c1fbdee4dda72c5342fcaf824d49a
  zedSymmetric :: PegBoard.Board -> PegBoardSymmetries.Symmetries
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: PegBoard.Board ->
                 case w of ww { PegBoard.Board ww1 ww2 ->
                 PegBoardSymmetries.$wzedSymmetric ww1 ww2 }) -}
baa5c587231da4d6a48ff4dbc4caa771
  zedSymmetric1 :: PegBoardSymmetries.Symmetries
  {- HasNoCafRefs, Strictness: m6,
     Unfolding: (PegBoardSymmetries.Not
                   PegBoardSymmetries.Horizontal) -}
instance GHC.Show.Show [PegBoardSymmetries.Symmetries]
  = PegBoardSymmetries.$fShowSymmetries
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

